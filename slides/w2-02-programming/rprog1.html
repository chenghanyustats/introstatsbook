<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>MATH 4720/MSSC 5720 Introduction to Statistics</title>
    <meta charset="utf-8" />
    <meta name="author" content="Dr.¬†Cheng-Han Yu   Department of Mathematical and Statistical Sciences   Marquette University" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/font-awesome/css/all.css" rel="stylesheet" />
    <link href="libs/font-awesome/css/v4-shims.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link rel="stylesheet" href="square_bullet.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, inverse, middle, title-slide

.title[
# MATH 4720/MSSC 5720 Introduction to Statistics
]
.subtitle[
## You RRR a Beginner: Operators and Data Types üë©‚Äçüíª
]
.author[
### Dr.¬†Cheng-Han Yu <br> Department of Mathematical and Statistical Sciences <br> Marquette University
]
.date[
### September 07 2022
]

---





layout: true

&lt;style&gt;
p.caption {
  font-size: 0.6em;
}
&lt;/style&gt;

&lt;!-- &lt;div class="my-footer"&gt; --&gt;
&lt;!-- &lt;span&gt; --&gt;
&lt;!-- &lt;a href="https://d2l.mu.edu/d2l/home/431031" target="_blank"&gt;D2L Website&lt;/a&gt; --&gt;
&lt;!-- &lt;/span&gt; --&gt;
&lt;!-- &lt;/div&gt; --&gt;

&lt;!-- &lt;style type="text/css"&gt; --&gt;
&lt;!-- .caption { --&gt;
&lt;!--     font-size: x-small; --&gt;
&lt;!--     text-align: center; --&gt;
&lt;!-- } --&gt;
&lt;!-- &lt;/style&gt; --&gt;


---









## R is a Calculator - Arithmetic Operators

&lt;img src="./img/arithmetic_operator.png" width="70%" style="display: block; margin: auto;" /&gt;

???
- We are already equipped with the tools we need for doing statistics in this course. Now it's time to program in R.
- We are going to go through basic R syntax and its commonly used data structures.
- Because some of you have no experience in R, this introduction is a must, because I want to make sure everyone is on the same page. 
- If you are already familiar with basic R syntax, please bear with me. You can learn more advanced stuff by yourself. OK.
- First, as many other languages, R is a calculator. We can do basic arithmetic operations using R.
- To get the remainder of division, we use two percentage symbols.
- To get the quotient of division, we use percent, slash and percent symbol.

---


## R is a Calculator - Examples


```r
2 + 3 * 5 + 4
```

```
## [1] 21
```

```r
2 + 3 * (5 + 4)
```

```
## [1] 29
```

???
???
- Here are some examples. Very simple. 

--

- We have to do the operation in the parenthesis first

&lt;img src="./img/pemdas.jpeg" width="80%" style="display: block; margin: auto;" /&gt;

???
- But keep the PEMDAS rule in mind, the order of operations.
- We do operations on parenthesis first, then exponentiation, then multiplication/division and then addition/subtraction. OK.


---


## R Does Comparisons - Logical Operators

&lt;img src="./img/logical_operator.png" width="40%" style="display: block; margin: auto;" /&gt;


???
- Here are some commonly used comparison and logical operators
- comparing to python, the difference is that R uses ! to negate the result, vertical bar | for or and &amp; for and 
- There is a R buil-in function isTRUE() to test if x is TRUE.
- "||" and "&amp;&amp;" only evaluate/compare the first element of vectors.



---
## R Can Do Comparisons - Examples

.pull-left[

```r
5 &lt;= 5
```

```
## [1] TRUE
```

```r
5 &lt;= 4
```

```
## [1] FALSE
```

```r
# Is 5 is NOT equal to 5? FALSE
5 != 5
```

```
## [1] FALSE
```
]


--

.pull-right[

```r
## Is TRUE not equal to FALSE?
TRUE != FALSE
```

```
## [1] TRUE
```

```r
## Is not TRUE equal to FALSE?
!TRUE == FALSE
```

```
## [1] TRUE
```

```r
## TRUE if either one is TRUE or both are TRUE
TRUE | FALSE
```

```
## [1] TRUE
```
]

--

.question[
What does `TRUE &amp; FALSE` return?
]


???
- 5 == 5.000
- 5 == 5L
- When we do OR comparison, it returns true if either one is TRUE or both are TRUE.
- When we do AND comparison, it returns true if both are TRUE.
- ## Is TRUE equal to FALSE?
- TRUE == FALSE
&lt;!-- # 5 and 5.00 and 5.000 are of the same value --&gt;
&lt;!-- 5 == 5.00 --&gt;
&lt;!-- # 5 and 5L are of the same value too --&gt;
&lt;!-- # 5 is of type double; 5L is of type integer --&gt;
&lt;!-- 5 == 5L --&gt;



---
exclude:true
## R Can Do Comparisons - Examples Cont'd


```r
## When doing AND/OR comparisons, all nonzero values are treated as TRUE and 0 as FALSE.
1 | 0
```

```
## [1] TRUE
```

```r
2 | 0
```

```
## [1] TRUE
```

```r
0 | 0
```

```
## [1] FALSE
```

```r
0 &amp; 0
```

```
## [1] FALSE
```

```r
1 &amp; 0
```

```
## [1] FALSE
```

```r
1 &amp; 1
```

```
## [1] TRUE
```


---
exclude:true
## Truth table

&lt;img src="./img/boolean.png" width="100%" style="display: block; margin: auto;" /&gt;

???
- So what I did in the previous slide is just this truth table. And I believe you already learned it in 1010.

---

## Build-in Functions

- R has lots of built-in functions, especially for mathematics, probability and statistics.

&lt;img src="./img/numeric_fcns.png" width="45%" style="display: block; margin: auto;" /&gt;

???
- No importing other modules or libraries is required. 
- These functions are pretty similar to the MATLAB or python functions, right?
- piece of cake!
- We'll learn more about them together when we are actually doing probability and statistics




---



## Build-in Functions - Examples

.pull-left[

```r
sqrt(144)
```

```
## [1] 12
```

```r
exp(1)  ## Euler's number
```

```
## [1] 2.718
```

```r
sin(pi/2)
```

```
## [1] 1
```

```r
abs(-7)
```

```
## [1] 7
```
]

--

.pull-right[

```r
factorial(5)
```

```
## [1] 120
```

```r
## without specifying base value
## it is a natural log with base e
log(100)
```

```
## [1] 4.605
```

```r
## log function and we specify base = 2
log(100, base = 10)
```

```
## [1] 2
```
]

???
- Do you know what factorial means? 
- Look at the log function. without specifying base value, it is a natural log with base e.
- If you want to use another base, specify it in the argument base.

---
## Commenting
.question[
You've seen comments a lot! How do we write a comment in R?
]

--
- Use `#` to add a comment so that the text after `#` is not read as an R command.
- Writing (good) comments is highly recommended: help readers and more importantly yourself understand what the code is doing.
- Comments should explain the **why**, not the what.


---
.pull-left[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/cat_comment.png" alt="https://www.reddit.com/r/ProgrammerHumor/comments/8w54mx/code_comments_be_like/" width="100%" /&gt;
&lt;p class="caption"&gt;https://www.reddit.com/r/ProgrammerHumor/comments/8w54mx/code_comments_be_like/&lt;/p&gt;
&lt;/div&gt;
]

.pull-right[
&lt;img src="./img/stop_comment.png" width="100%" style="display: block; margin: auto;" /&gt;
]



---

## Objects and Funtions in R
&gt; &lt;span style="color:red"&gt; Everything that **exists** is an **object**. &lt;/span&gt;  
&lt;span style="color:red"&gt; Everything that **happens** is a **function call**. &lt;/span&gt;  
  -- *[John Chambers](https://bit.ly/3yJJGrC), the creator of the S programming language*.

- We have made lots of things happened!
- Even arithmetic and logical operators are functions!

```r
`+`(x = 2, y = 3)
```

```
## [1] 5
```

```r
`&amp;`(TRUE, FALSE)
```

```
## [1] FALSE
```



???
- To understand computation in R, two slogans are helpful:
- S programming language is the predecessor of R.
- Let's create different types of objects and learn about their properties.
- B. Sc. 1963 - University of Toronto, Mathematics
- M. A. 1965 - Harvard University, Statistics
- Ph.D. 1966 - Harvard University, Statistics
&lt;!-- -- --&gt;

&lt;!-- .question[ --&gt;
&lt;!-- Did we create R objects already? --&gt;
&lt;!-- ] --&gt;

&lt;!-- - So far, the Environment is empty, as we haven't created any R objects. --&gt;



---
## Creating Variables

- A variable stores a value that can be changed according to our need.
- Use `&lt;-` operator to **assign** a value to the variable. (Highly recommendedüëç)


```r
x &lt;- 5  ## we create an object, value 5, and call it x, which is a variable.
x  ## type the variable name to see the value stored in the object x
```

```
## [1] 5
```

&lt;!-- - Can also use `=` symbol to do assignment. (‚ùå Does not work in some situations) --&gt;


```r
(x &lt;- x + 6)  # We can reassign any value to the variable we created
```

```
## [1] 11
```

```r
x == 5  # We can perform any operations on variables
```

```
## [1] FALSE
```

```r
log(x) # Variables can also be used in any built-in functions
```

```
## [1] 2.398
```


---
exclude:false
background-image: url("./img/r_assign_syntax.jpg")
background-position: 50% 50%
background-size: contain
class: center, bottom, inverse

[Why do we use arrow as an assignment operator](https://colinfay.me/r-assignment/)



---


## Bad Naming
- ‚ùå Unless you have a very good reason, don't create a variable whose name is the same as any R [*built-in constant*](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Constants.html) or function!
- üòü It causes lots of confusion when your code is long and when others read your code.


```r
## THIS IS BAD CODING! DON'T DO THIS!
pi  ## pi is a built-in constant
```

```
## [1] 3.142
```

```r
(pi &lt;- 20)
```

```
## [1] 20
```

```r
abs ## abs is a built-in function
```

```
## function (x)  .Primitive("abs")
```

```r
(abs &lt;- abs(pi))
```

```
## [1] 20
```


---
class: center, middle, inverse

# Object Types


???
- We know we can create R objects, right? And objects may have different types.
- Object Type plays an important role in data analysis, because it affects which model we should use and which functions we should use to manipulate our data.


---
exclude:true
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="./img/simpleview.png" alt="https://speakerdeck.com/jennybc/simple-view-of-r-objects?slide=3" width="80%" /&gt;
&lt;p class="caption"&gt;https://speakerdeck.com/jennybc/simple-view-of-r-objects?slide=3&lt;/p&gt;
&lt;/div&gt;


???
- In statistics, we can have different data types, categorical and numerical variables.
- In R, basic object type includes character, logical, numeric and factor.
- But things are not that easy. 
- In R, there are three ways to to view an R object, its mode, its class, and its type. 
- And an interesting thing is that factor has a numeric mode, factor class and integer type. We'll talk about that later today.


---

## Types of Variables
- Use **`typeof()`** to check which type a variable belongs to.
- Common types include **`character`**, **`double`**, **`integer`** and **`logical`**.
- Check if it‚Äôs of a specific type: **`is.character()`**, **`is.double()`**, **`is.integer()`**, **`is.logical()`**.
&lt;!-- - To specify an integer, we type a number followed by letter `L`.  --&gt;

.pull-left[

```r
typeof(5)
```

```
## [1] "double"
```

```r
typeof(5L)
```

```
## [1] "integer"
```

```r
typeof("I_love_stat!")
```

```
## [1] "character"
```
]
.pull-right[

```r
typeof(1 &gt; 3)
```

```
## [1] "logical"
```

```r
is.double(5L)
```

```
## [1] FALSE
```
]


???
- Use R command **`typeof()`** to check which type a variable belongs to.
- Common types include **`character`**, **`double`**, **`integer`** and **`logical`**.
- Check if it‚Äôs a specific type with an "is" function: **`is.character()`**, **`is.double()`**, **`is.integer()`**, **`is.logical()`**.
- The potential confusion is that R has used mode "numeric" to mean ‚Äòdouble or integer‚Äô, which conflicts with the S4 usage. Thus is.numeric tests the mode, not the class, but as.numeric (which is identical to as.double) coerces to the class.



---
## Variable Types in R and in Statistics
- Type `character` and `logical` correspond to **categorical** variables.
- Type `logical` is a special type of categorical variables that has only two categories (**binary**). 
&lt;!-- - We usually call it a **binary** variable. --&gt;
- Type `double` and `integer` correspond to **numerical** variables. (an exception later)
  + Type `double` is for **continuous** variables
  + Type `integer` is for **discrete** variables.




???
- Both `double` and `integer` types are of `numeric` type.


```r
is.numeric(5)
```

```
## [1] TRUE
```

```r
is.numeric(5L)
```

```
## [1] TRUE
```
- typeof(as.numeric(5L)) returns "double"

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r numeric} --&gt;
&lt;!-- mode(5) --&gt;
&lt;!-- mode(5L) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;
&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- is.numeric(5) --&gt;
&lt;!-- is.numeric(5L) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;



---


class: center, middle, inverse

# R Data Structures

## Vector
## Factor
## List
## Matrix
## Data Frame

???
- Now let's learn some common R Data Structures, including 

---


## (Atomic) Vector
- To create a vector, use `c()`, short for *concatenate* or *combine*.
- **All** elements of a vector must be of the **same type**. 

.pull-left[

```r
(dbl_vec &lt;- c(1, 2.5, 4.5)) 
```

```
## [1] 1.0 2.5 4.5
```

```r
(int_vec &lt;- c(1L, 6L, 10L))
```

```
## [1]  1  6 10
```

```r
## TRUE and FALSE can be written as T and F
(log_vec &lt;- c(TRUE, FALSE, F))  
```

```
## [1]  TRUE FALSE FALSE
```

```r
(chr_vec &lt;- c("pretty", "girl"))
```

```
## [1] "pretty" "girl"
```
]

.pull-right[

```r
## check how many elements in a vector
length(dbl_vec) 
```

```
## [1] 3
```

```r
## check a compact description of 
## any R data structure
str(dbl_vec) 
```

```
##  num [1:3] 1 2.5 4.5
```
]

---
exclude:true
## Sequence of Numbers
- Use `:` to create a *sequence of integers*.
- A general way to create a sequence of numbers is to use `seq()` function.
- Vectors created by `seq()` are of type `double`.


```r
## use `:` to create a sequence of integers
(vec &lt;- 1:10) 
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
typeof(vec)
```

```
## [1] "integer"
```

```r
# a sequence of numbers from 1 to 10 with increment 2
(seq_vec &lt;- seq(from = 1, to = 10, by = 2))
```

```
## [1] 1 3 5 7 9
```

```r
typeof(seq_vec)
```

```
## [1] "double"
```



---


## Operations on Vectors
- We can do any operations on vectors as we do on a *scalar* variable (vector of length 1).

.pull-left[

```r
# Create two vectors
v1 &lt;- c(3, 8)
v2 &lt;- c(4, 100) 

## All operations happen element-wisely
# Vector addition
v1 + v2
```

```
## [1]   7 108
```

```r
# Vector subtraction
v1 - v2
```

```
## [1]  -1 -92
```
]
.pull-right[

```r
# Vector multiplication
v1 * v2
```

```
## [1]  12 800
```

```r
# Vector division
v1 / v2
```

```
## [1] 0.75 0.08
```

```r
sqrt(v2)
```

```
## [1]  2 10
```
]

???
- we can also use a function on vectors if vectors are accepted, for example, log() and sqrt().
- The function will work on each element of the vector, and then return a result of the same length of the vector.


---

## Recycling of Vectors
- If we apply arithmetic operations to two vectors of **unequal** length, the elements of the shorter vector will be **recycled** to complete the operations.
&lt;!-- - Beware of recycling! --&gt;
&lt;!-- - The concept of *recycling* helps us write more concise code. --&gt;


```r
v1 &lt;- c(3, 8, 4, 5)
# The following 2 operations are the same
v1 * 2
```

```
## [1]  6 16  8 10
```

```r
v1 * c(2, 2, 2, 2)
```

```
## [1]  6 16  8 10
```

```r
v3 &lt;- c(4, 11)
v1 + v3  ## v3 becomes c(4, 11, 4, 11) when doing the operation
```

```
## [1]  7 19  8 16
```

???
- Let's see what does recyling mean.
- We have v1. The following 2 operations are the same. V1 * 2 means that each element in V1 is multiplied by 2. So it is equivalent to multiply by a vector of 2 of the same length of V1.
- Suppose we have a vector 
---


## Subsetting Vectors
- To extract element(s) in a vector, use a pair of brackets `[]` with element indexing.
- The indexing **starts with 1**.

.pull-left[

```r
v1
```

```
## [1] 3 8 4 5
```

```r
v2
```

```
## [1]   4 100
```

```r
## The first element
v1[1] 
```

```
## [1] 3
```

```r
## The second element
v2[2]  
```

```
## [1] 100
```
]
.pull-right[

```r
v1[c(1, 3)]
```

```
## [1] 3 4
```

```r
## extract all except a few elements
## put a negative sign before the vector of 
## indices
v1[-c(2, 3)] 
```

```
## [1] 3 5
```


]

???
- If we want to extract one or more elements in a vector, we use a pair of brackets `[]` with element indexing after the vector's name.
- The indexing **starts with 1**.
- We can put a sequence of numbers inside the brackets to extract multiple elements.
- For example, we can use 2:4 to extract the second to 4th element
- We can also use the vector c(1, 3) to extract the first and the third element
- If we want to extract all but a few elements, just put a negative sign before the vector of indices.
- For example v1[-c(2, 3)] keeps all the elements except the second and the third one.

---


## Factor
- A vector of type `factor` can be *ordered in a meaningful way.* 
- Create a factor by `factor()`. It is a type of **integer**, not **character**. üò≤  üôÑ 


```r
fac &lt;- factor(c("med", "high", "low"))
typeof(fac)
```

```
## [1] "integer"
```

```r
levels(fac) ## Each level represents an integer, ordered from the vector alphabetically.
```

```
## [1] "high" "low"  "med"
```

```r
str(fac)  ## The integers show the level each element in vector fac belongs to.
```

```
##  Factor w/ 3 levels "high","low","med": 3 1 2
```

```r
order_fac &lt;- factor(c("med", "high", "low"), levels = c("low", "med", "high"))
str(order_fac)
```

```
##  Factor w/ 3 levels "low","med","high": 2 3 1
```


???
- A vector of type `factor` can be ordered in a meaningful way, but difference is meaningless. (**ordinal** level of measurement)
- Because a factor is an ordered vector, there is a level associated with it.
- Here, the level of fac from the lowest to highest is "bad"  "good"    "neutral"
- Each level represents an integer, by default they are ordered from the vector alphabetically.
- R stores a level using integers. So "bad" is 1, "good" is 2, and "neutral" is 3.
- If we check its structure, it tells us it is a factor with 3 levels, the first element is bad, corresponding to the first level bad, so its number is 1. 
- The second element is neutral, corresponding to the third level, so its number is 3. And the good has the number 2, because it is with the second level.
- Well ordering a factor alphabetically is not what we want here, right?
- We can specify the level we want using the argument "levels" in the factor function. For example here, we tell R that the level of this factor, from the lowest to highest is "bad", "neutral", "good".
- And now the factor is correctly ordered showing 1, 2, 3 here.
- We will touch factors a little bit at the end of the semester.
---


## List (Generic Vectors)
- Lists are different from vectors: Elements can be of **any type**, including lists.
- Construct a list by using **`list()`** instead of `c()`.

.pull-left[

```r
## a list of 3 elements of different types
x_lst &lt;- list(idx = 1:3, 
              "a", 
              c(TRUE, FALSE))
x_lst
```

```
## $idx
## [1] 1 2 3
## 
## [[2]]
## [1] "a"
## 
## [[3]]
## [1]  TRUE FALSE
```
]

.pull-right[

```r
str(x_lst)
```

```
## List of 3
##  $ idx: int [1:3] 1 2 3
##  $    : chr "a"
##  $    : logi [1:2] TRUE FALSE
```

```r
names(x_lst)
```

```
## [1] "idx" ""    ""
```

```r
length(x_lst)
```

```
## [1] 3
```
]

---


## Subsetting a List


```r
x_lst &lt;- list(idx = 1:3, 
              "a", 
              c(TRUE, FALSE))
```

.pull-left[
&lt;br&gt;
**Return an &lt;span style="color:red"&gt; element &lt;/span&gt; of a list**


```r
## subset by name (a vector)
x_lst$idx  
```

```
## [1] 1 2 3
```

```r
## subset by indexing (a vector)
x_lst[[1]]  
```

```
## [1] 1 2 3
```

```r
typeof(x_lst$idx)
```

```
## [1] "integer"
```
]

--

.pull-right[
&lt;br&gt;
**Return a &lt;span style="color:red"&gt; sub-list &lt;/span&gt; of a list**



```r
## subset by name (still a list)
x_lst["idx"]  
```

```
## $idx
## [1] 1 2 3
```

```r
## subset by indexing (still a list)
x_lst[1]  
```

```
## $idx
## [1] 1 2 3
```

```r
typeof(x_lst["idx"])
```

```
## [1] "list"
```
]


???
- This is where we should pay more attention to. When we subset a list, it may return an element of the list, or it returns a sub-list of the list.
- Let's see how it happens. 
- This is our x_lst. We can subset a list by name or by indexing. 
- Suppose we want the first element of the list, we can get it by its name using x_lst$idx.
- We can also obtain it by using indexing like x_lst[[1]] because we want the first element.
- Notice that the way we subset a list returns an integer vector, the real first element of the list, not a list. 
- Let's see another case on the right.
- We can also subset by name using single pair of brackets, and put the name inside the brackets with quotation marks.
- Or we can subset by indexing, using a single pair of brackets instead.
- And you see what happened? The way we subset a list here returns a sub-list, not the element itself. 
- So please be careful when subsetting a list. 
- If you want a vector, use these ways. If you want to keep it as a list, use these ways.

---
&lt;img src="./img/list_condiment.png" width="80%" style="display: block; margin: auto;" /&gt;

???
- OK. We know images speak louder than words. Here you go.
- Is it clear enough? Do I need to explain the idea to you?
- Pepper shaker / packet


---

&gt; If list `x` is a train carrying objects, then `x[[5]]` is
&gt; the object in car 5; `x[4:6]` is a train of cars 4-6.
&gt;
&gt; --- \@RLangTip, &lt;https://twitter.com/RLangTip/status/268375867468681216&gt;

&lt;img src="https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/subsetting/train.png" width="100%" style="display: block; margin: auto;" /&gt;

&lt;img src="https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/subsetting/train-single.png" width="100%" style="display: block; margin: auto;" /&gt;



---
## Matrix

- A matrix is a *two-dimensional analog of a vector*.
- Use command `matrix()` to create a matrix.


```r
## Create a 3 by 2 matrix called mat
(mat &lt;- matrix(data = 1:6, nrow = 3, ncol = 2)) 
```

```
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
```

```r
dim(mat); nrow(mat); ncol(mat)
```

```
## [1] 3 2
```

```
## [1] 3
```

```
## [1] 2
```

???
- By default, R creates a matrix column by column. 
- R is a column major language.

&lt;!-- - Row-major order is used in C/C++/Objective-C (for C-style arrays), PL/I,[4] Pascal,[5] Speakeasy,[citation needed] SAS,[6] and Rasdaman.[7] --&gt;

&lt;!-- - Column-major order is used in Fortran, MATLAB,[8] GNU Octave, S-Plus,[9] R,[10] Julia,[11] and Scilab.[12] --&gt;



&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r matrix, tidy=FALSE} --&gt;
&lt;!-- ## Create a 3 by 2 matrix called mat --&gt;
&lt;!-- (mat &lt;- matrix(data = 1:6,  --&gt;
&lt;!--                nrow = 3,  --&gt;
&lt;!--                ncol = 2))  --&gt;
&lt;!-- dim(mat); nrow(mat); ncol(mat) --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r, tidy=FALSE} --&gt;
&lt;!-- # elements are arranged by row --&gt;
&lt;!-- matrix(data = 1:6,  --&gt;
&lt;!--        nrow = 3,  --&gt;
&lt;!--        ncol = 2,  --&gt;
&lt;!--        byrow = TRUE) #&lt;&lt; --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;


---
exclude:true
## Row and Column Names

```r
mat
```

```
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
```

```r
## assign row names and column names
rownames(mat) &lt;- c("A", "B", "C")
colnames(mat) &lt;- c("a", "b")
mat
```

```
##   a b
## A 1 4
## B 2 5
## C 3 6
```

```r
rownames(mat)
```

```
## [1] "A" "B" "C"
```

```r
colnames(mat)
```

```
## [1] "a" "b"
```

???
- Actually a matrix can have its row name and column name
- dimnames(mat)



---


## Subsetting a Matrix
- To extract a sub-matrix, use the same indexing approach as vectors on rows and columns.
- Use comma `,` to separate row and column index.
- `mat[2, 2]` extracts the element of the second row and second column.

.pull-left[

```r
mat
```

```
##   a b
## A 1 4
## B 2 5
## C 3 6
```

```r
## all rows and 2nd column
## leave row index blank
## specify 2 in coln index
mat[, 2]
```

```
## A B C 
## 4 5 6
```
]
.pull-right[

```r
## 2nd row and all columns
mat[2, ] 
```

```
## a b 
## 2 5
```

```r
## The 1st and 3rd rows
mat[c(1, 3), ] 
```

```
##   a b
## A 1 4
## C 3 6
```
]


???
- Similar to vector, we use [] to subset a matrix.
- Because a matrix has row index and column index, we use comma `,` to separate row and column index of a matrix.
- mat[, 2] automatically becomes a vector.
- class(mat[, 2])
- class(mat[, 2, drop = FALSE])

---
exclude:true
## One-row and One-column Matrix
- When a single row or single column is extracted, the one-row or one-column matrix is reduced to a vector.
- To keep its matrix property, we use `drop = FALSE` when subsetting a matrix.

.pull-left[

```r
(one_col_vec &lt;- mat[, 2])
```

```
## A B C 
## 4 5 6
```

```r
class(one_col_vec)
```

```
## [1] "integer"
```
]

.pull-right[

```r
(one_col_mat &lt;- mat[, 2, 
*                   drop = FALSE])
```

```
##   b
## A 4
## B 5
## C 6
```

```r
class(one_col_mat)
```

```
## [1] "matrix" "array"
```
]
---


## Binding Matrices
- We can generalize `c()` used in vectors to `cbind()` (binding matrices by adding columns) and `rbind()` (binding matrices by adding rows) for matrices.
- When matrices are combined by columns (rows), they should have the same number of rows (columns).

.pull-left[

```r
mat
```

```
##   a b
## A 1 4
## B 2 5
## C 3 6
```

```r
mat_c &lt;- matrix(data = c(7, 0, 0, 8, 2, 6), 
                nrow = 3, ncol = 2)
## should have the same number of rows
cbind(mat, mat_c)  
```

```
##   a b    
## A 1 4 7 8
## B 2 5 0 2
## C 3 6 0 6
```
]

.pull-right[

```r
mat_r &lt;- matrix(data = 1:4, 
                nrow = 2, 
                ncol = 2)
## should have the same number of columns
rbind(mat, mat_r)  
```

```
##   a b
## A 1 4
## B 2 5
## C 3 6
##   1 3
##   2 4
```
]


---
## Data frame: The Most Common Way of Storing Data

- A data frame is of type **list** of *equal-length* vectors, having a *2-dimensional* structure.
- More general than matrix: Different columns can have different types.
- To create a data frame, use `data.frame()` that takes *named* vectors as input.

.pull-left[

```r
## data frame w/ an dbl column named  
## and char column named grade.
(df &lt;- data.frame(age = c(19,21,40), 
                  gender = c("m","f","m")))
```

```
##   age gender
## 1  19      m
## 2  21      f
## 3  40      m
```

```r
## a data frame has a list structure
str(df)  
```

```
## 'data.frame':	3 obs. of  2 variables:
##  $ age   : num  19 21 40
##  $ gender: chr  "m" "f" "m"
```
]

--

.pull-right[

```r
## must set column names
## or they are ugly and non-recognizable
data.frame(c(19, 21, 40), c("m","f", "m")) 
```

```
##   c.19..21..40. c..m....f....m..
## 1            19                m
## 2            21                f
## 3            40                m
```
]


???
- The Most Common Way of Storing Data. 
- In fact, the data matrix we discussed before can be and should be stored as a data frame in R.
- each column vector is an element of the list.
- double, integer, character, factor, etc.
- typeof(df)

---
## Properties of Data Frames
- Data frame has properties of matrix and list.

.pull-left[

```r
names(df)  ## df as a list
```

```
## [1] "age"    "gender"
```

```r
colnames(df)  ## df as a matrix
```

```
## [1] "age"    "gender"
```

```r
length(df) ## df as a list
```

```
## [1] 2
```

```r
ncol(df) ## df as a matrix
```

```
## [1] 2
```

```r
dim(df) ## df as a matrix
```

```
## [1] 3 2
```
]
.pull-right[

```r
## rbind() and cbind() can be used on df

df_r &lt;- data.frame(age = 10, 
                   gender = "f")
rbind(df, df_r)
```

```
##   age gender
## 1  19      m
## 2  21      f
## 3  40      m
## 4  10      f
```

```r
df_c &lt;- 
    data.frame(col = c("red","blue","gray"))
(df_new &lt;- cbind(df, df_c))
```

```
##   age gender  col
## 1  19      m  red
## 2  21      f blue
## 3  40      m gray
```
]


---
## Subsetting a Data Frame
- When we subset data frames, we can use either list or matrix subsetting methods.

.pull-left[

```r
df_new
```

```
##   age gender  col
## 1  19      m  red
## 2  21      f blue
## 3  40      m gray
```

```r
## Subset rows
df_new[c(1, 3), ]
```

```
##   age gender  col
## 1  19      m  red
## 3  40      m gray
```

```r
## select the row where age == 21
df_new[df_new$age == 21, ]
```

```
##   age gender  col
## 2  21      f blue
```
]

.pull-right[

```r
## Subset columns
## like a list
df_new$age
```

```
## [1] 19 21 40
```

```r
df_new[c("age", "gender")]
```

```
##   age gender
## 1  19      m
## 2  21      f
## 3  40      m
```

```r
## like a matrix
df_new[, c("age", "gender")]
```

```
##   age gender
## 1  19      m
## 2  21      f
## 3  40      m
```
]


???


```r
str(df["age"])  ## a data frame with one column
```

```
## 'data.frame':	3 obs. of  1 variable:
##  $ age: num  19 21 40
```

```r
str(df[, "age"])  ## becomes a vector by default
```

```
##  num [1:3] 19 21 40
```



---
.your-turn[
- Create a vector object called `x` that has 5 elements 3, 6, 2, 9, 14.
- Compute the average of elements of `x`.
- Subset the `mtcars` data set by selecting variables `mpg` and `disp`.
- Select the cars (rows) in `mtcars` that have 4 cylinders.
]

--


```r
x &lt;- c(3, 6, 2, 9, 14)
mean(x)
mtcars[, c("mpg", "disp")]
mtcars[mtcars$cyl == 4, ]
```



???

```r
x &lt;- c(3, 6, 2, 9, 14)
mean(x)
```

```
## [1] 6.8
```



---
exclude:true
## Object Type Summary
.lab[
- Go to your **lab-yourname** project under our course workspace **2021-spring-math-3570** in RStudio Cloud.
- Create a R script named **lab03-objecttype.R**.
- In the R script, create R objects vector, factor, list, matrix and data frame.
- Examine `typeof()`, `mode()` and `class()` of those objects.
- Create a list to store your results.
]


&lt;!-- - Vectors' elements named --&gt;
&lt;!-- - Vectors coercion --&gt;
&lt;!-- str(df["var1"])  ## a data frame with one column --&gt;
&lt;!-- str(df[, "var1"])  ## becomes a vector by default --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Readings --&gt;

&lt;!-- - r4ds: [Vectors](https://r4ds.had.co.nz/vectors.html) --&gt;
&lt;!-- - ids: [R basics](https://rafalab.github.io/dsbook/r-basics.html) --&gt;

---
exclude:true

```
## $vector_type
##      type      mode     class 
##  "double" "numeric" "numeric" 
## 
## $factor_type
##      type      mode     class 
## "integer" "numeric"  "factor" 
## 
## $list_type
##   type   mode  class 
## "list" "list" "list" 
## 
## $matrix_type
##      type      mode    class1    class2 
## "integer" "numeric"  "matrix"   "array" 
## 
## $df_type
##         type         mode        class 
##       "list"       "list" "data.frame"
```

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9.5",
"highlightLines": true,
"highlightStyle": "tomorrow-night-bright",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
