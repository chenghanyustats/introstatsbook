# Data Sample Statistics {#sec-data-numeric}

```{r packages, echo=FALSE, message=FALSE, warning=FALSE, purl=FALSE}
library(tidyverse)
library(fontawesome)
library(fields)
library(microbenchmark)
library(openintro)
library(emoji)
library(kableExtra)
``` 


<span style="color:blue"> **Numerical Summaries of Data** </span>

::::{.columns}
:::{.column width="50%"}
```{r, echo=FALSE, out.width="100%", purl=FALSE, fig.align='center'}
knitr::include_graphics("./images/img-data/number.jpeg")
```

:::{.callout-note icon=false}
## If you need to choose one value that represents the entire data, what value would you choose?
:::
:::

:::{.column width="50%"}
- **Measure of Center**
  - We typically use the **middle** point. 
  - What does "middle" mean?
- **Measure of Variation** 
  - What values tell us how much variation a variable has?
:::
::::

## Measures of Center

<span style="color:blue"> **Mean** </span>

- The **(arithmetic) mean or average** is calculated by adding up all of the values and then dividing by the total number of them.
- The **population mean** is denoted as $\mu$.
- Let $x_1, x_2, \dots, x_n$ denote the measurements observed in a sample of size $n$. 
  - The **sample mean** is defined as

<center>  
$$\overline{x} = \frac{\sum_{i=1}^{n} x_i}{n} = \frac{x_1 + x_2 + \dots + x_n}{n}$$
</center>

- For the interest rate example,

<center>
$$\overline{x} = \frac{10.9\% + 9.9\% + \cdots + 6.1\%}{50} = 11.56\%$$
</center>

<span style="color:red"> ***Calculate Mean in R*** </span>

```{r, message=FALSE, warning=FALSE, purl=FALSE, echo=FALSE}
int_rate <- round(loan50$interest_rate, 1)
```

```{r}
mean(int_rate)
```

<span style="color:red"> ***Balancing Point*** </span>

- Think of the mean as the **balancing point** of the distribution.

::::{.columns}
:::{.column width="49%"}
```{r, echo=FALSE, cache=TRUE, out.width="100%", purl=FALSE}
#| label: fig-balance
#| fig-cap: Mean as a balancing point for interest rate example
par(mar = c(4, 0, 0, 0))
par(mfrow = c(1, 1))
round.to <- 1
binned <- round.to * round(int_rate / round.to)
tab <- table(binned)
cex <- 1
xlim <- c(0.9 * min(int_rate), 1.05 * max(int_rate))
plot(0,
     type = "n",
     xlab = "Interest Rate, Rounded to Nearest Percent",
     ylab = "",
     axes = FALSE,
     xlim = xlim,
     ylim = c(-1, 1.5 * max(tab)))
for (i in 1:length(tab)) {
  points(rep(as.numeric(names(tab[i])), tab[i]),
         1.5 * (1:tab[i]) - 0.4,
         pch = 19,
         col = 4,
         cex = 2 * cex)
}
abline(h = 0)
openintro::AxisInPercent(1, pretty(c(0, int_rate)))
M <- mean(int_rate)
polygon(M + c(-1, 1, 0) * 1,
        c(-1.2, -1.2, -0.1),
        border = "red",
        col = 2)
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
```{r, echo=FALSE, out.width="100%", purl=FALSE, fig.align='center'}
knitr::include_graphics("./images/img-data/seesaw.jpeg")
```
:::
::::

--------------------------------------------------------------

<span style="color:blue"> **Median** </span>

- The **median** is the *middle value* when data values are *sorted*.
- Half of the values are less than or equal to the median, and the other half are greater than the median. 
- To find the median, we first sort the values.
- If $n$ is **odd**, the median is located in the *exact middle* of the ordered values.
   + <span style="color:blue"> Data: (0, 2, 10, 14, 8) </span>
   + <span style="color:blue"> Sorted Data: (0, 2, <span style="color:red">8</span>, 10, 14) </span>
   + <span style="color:blue"> The median is $8$ </span>.
- If $n$ is **even**, the median is the *average of the two middle numbers*.
   + <span style="color:blue"> Data: (0, 2, 10, 14, 8, 12) </span>
   + <span style="color:blue"> Sorted Data: (0, 2, <span style="color:red">8, 10</span>, 12, 14) </span>
   + <span style="color:blue"> The median is $\frac{8 + 10}{2} = 9$ </span>.
   

<span style="color:red"> ***Calculate Median in R*** </span>

- There are two ways to calculate the median in R.

```{r median, dependson='mean', tiny=FALSE}
median(int_rate)  ## Compute the median using command median()
``` 

```{r}
## Compute the median using definition
(sort_rate <- sort(int_rate))  ## sort data
length(int_rate)  ## Check sample size is odd or even
(sort_rate[25] + sort_rate[26]) / 2  ## Verify the answer
```

:::{.callout-warning}
## Warning
- Be sure to sort the data first if computing the median using its definition.
:::

```{r}
(int_rate[25] + int_rate[26]) / 2  ## Using un-sorted data leads to a wrong answer!!
```

------------------------------------------------------------

<span style="color:blue"> **Mode** </span>

- The **mode** is the value that occurs *most frequently*.
- For continuous numerical data, it is common for there not to be **any** observations that share the same value.
- A more practical definition is that a mode is represented by a **prominent peak** in the distribution.

<span style="color:red"> ***Calculate Mode in R*** </span>

```{r mode, echo = 1:2}
## Create a frequency table 
(table_data <- table(int_rate))
# sort_table_data <- sort(table_data, decreasing = TRUE)
# sort_table_data
# print(paste("The mode is",names(sort_table_data)[1]))
``` 


```{r}
## Sort the table to find the mode that occurs most frequently
## the number that happens most frequently will be the first one
sort(table_data, decreasing = TRUE)
```


## Comparison of Mean, Median and Mode
- The mode is applicable for both categorical and numerical data, while the median and mean work for numerical data only.
- It is also possible to have more than one mode, but there is only one median and one mean.
- The mean is sensitive to extreme values (outliers). 
- The median and mode are more **robust** than the mean.
  - Being more robust means these measures of center are more resistant to the addition of extreme values to the data.
  - An example in R is shown below:

```{r, tidy = FALSE, echo = -(1:2), highlight.output=1}
data_extreme <- int_rate; data_extreme[1] <- 90 ## replace the first 3 values with 3 large values 
## In the original data, the maximum value is 42.
data_extreme
```
```{r}
mean(data_extreme)  ## Large mean! Original mean is 11.56
median(data_extreme)  ## Median does not change!
names(sort(table(data_extreme), decreasing = TRUE))[1] ## Mode does not change either!
```

- Below is a figure that shows the differences in where the mean, median, and mode lie for skewed distributions vs. symmetric distributions.

```{r, echo=FALSE, results='hide', out.width="100%",fig.align='center', fig.asp=0.4, purl=FALSE}
#| label: fig-extreme-data
#| fig-cap: Comparison of mean, median, and mode for symmetrical vs. skewed distributions
knitr::include_graphics("./images/img-data/skew_mean_median_mode.png")

par(mfrow = c(1, 3), mar = c(0.3, 0, 2, 0))
p <- seq(0, 1, length = 100)
a <- 2; b <- 5
max_d <- max(dbeta(p, a, b))
plot(p, dbeta(p, a, b), type = 'l', axes = FALSE, xlab = "", ylab = "", lwd = 3, ylim = c(0, max_d + 0.2)) + 
    title(main = "Right-Skewed") + 
    abline(v = (a - 1) / (a + b - 2), lty = 1, col = 1) + 
    abline(v = (a - 1/3) / (a + b - 2/3), lty = 2, col = 2) + 
    abline(v = a /(a + b), lty = 3, col = 4) + 
    text(x = (a - 1) / (a + b - 2)*0.7, y = max_d + 0.2, 
         labels = "Mode", col = 1) + 
    text(x = (a - 1/3) / (a + b - 2/3), y = max_d+0.08, 
         labels = "Median", col = 2) + 
    text(x = a /(a + b)*1.3, y = max_d-0.2, 
         labels = "Mean", col = 4)
axis(1, labels = FALSE, tick = TRUE)

x <- seq(-4, 4, length = 1000)
plot(x, dnorm(x), type = "l", ylim = c(0, 0.45), 
     main = "Symmetric", axes = FALSE, xlab = "", 
     ylab = "", lwd = 3)
abline(v = 0, lty = 2)
text(1.2, dnorm(0) + 0.02, "Mean = Median = Mode")
axis(1, labels = FALSE, tick = TRUE)


p <- seq(0, 1, length = 100)
a <- 5; b <- 2
max_d <- max(dbeta(p, a, b))

plot(p, dbeta(p, a, b), type = 'l', ylim = c(0, max_d + 0.2),
     axes = FALSE, xlab = "", ylab = "", lwd = 3) + 
    title(main = "Left-Skewed") + 
    abline(v = (a - 1) / (a + b - 2), lty = 1, col = 1) + 
    abline(v = (a - 1/3) / (a + b - 2/3), lty = 2, col = 2) + 
    abline(v = a /(a + b), lty = 3, col = 4) + 
    text(x = (a - 1) / (a + b - 2)*1.15, y = max_d + 0.2,
         labels = "Mode", col = 1) + 
    text(x = (a - 1/3) / (a + b - 2/3), y = max_d + 0.08, 
         labels = "Median", col = 2) + 
    text(x = a /(a + b)*0.85, y = max_d - 0.2, 
         labels = "Mean", col = 4)
axis(1, labels = FALSE, tick = TRUE)
```

## Measures of Variation

- Measures of variation, just like measures of center, affect the shape of the distribution (@fig-variation).

```{r variation, echo=FALSE, cache=TRUE, out.width="75%", purl=FALSE, fig.align='center'}
#| label: fig-variation
#| fig-cap: Effects of variation on the shape of distributions
normal_small <- rnorm(5000, 0, 0.1)
normal_median <- rnorm(5000, 0, 0.5)
normal_large <- rnorm(5000, 0, 0.9)
par(mfrow = c(3, 1))
par(mar = c(1,1,1,1))
hist(normal_small, xlim = c(-3.6, 3.6), breaks = 20, main = "Small Variation", 
     col = "#003366", border = "white", axes = FALSE, ylab = "", ylim = c(0, 1000))
abline(v = 0, col = "#FFCC00", lwd = 3)
hist(normal_median, xlim = c(-3.6, 3.6), breaks = 30, main = "Median Variation", 
     col = "#003366", border = "white", axes = FALSE, ylab = "", ylim = c(0, 1000))
abline(v = 0, col = "#FFCC00", lwd = 3)
hist(normal_large, xlim = c(-3.6, 3.6), breaks = 60, main = "Large Variation", 
     col = "#003366", border = "white",axes = FALSE, ylab = "", ylim = c(0, 1000))
abline(v = 0, col = "#FFCC00", lwd = 3)
```

------------------------------------------------------------------

<span style="color:blue"> ***p*-th percentile** </span>

::::{.columns}
:::{.column width="50%"}
- The **p-th percentile (quantile)** is a data value such that 
  - at most $p\%$ of the values are below it
  - at most $(1-p)\%$ of the values are above it

:::{.callout-note icon=false}
## There are two data sets with the same mean 20. 
  + One data set has 99-th percentile = 30, and 1-st percentile = 10. 
  + The other has 99-th percentile = 40, and 1-st percentile = 0. 
  + Which data set has larger variation?
:::
:::

:::{.column width="50%"}
```{r, echo=FALSE, out.width="36%",fig.align='center', purl=FALSE}
#| label: fig-act
#| fig-cap: Percentiles for ACT scores (https://en.wikipedia.org/wiki/ACT_(test))
knitr::include_graphics("./images/img-data/act_math_percentile.png")
```
:::
::::

--------------------------------------------------------------

<span style="color:blue"> **Interquartile Range (IQR)** </span>

- **First Quartile (Q1)**: the <span style="color:red">25-th</span> percentile
- **Second Quartile (Q2)**: the <span style="color:red">50-th</span> percentile (Median)
- **Third Quartile (Q3)**: the <span style="color:red">75-th</span> percentile
- **Interquartile Range (IQR)**: Q3 - Q1

::::{.columns}
:::{.column width="49%"}
```{r, iqr-1, tidy=FALSE}
## Use quantile() to find any percentile 
## through specifying the probability
quantile(x = int_rate, 
         probs = c(0.25, 0.5, 0.75))
## IQR by definition
quantile(x = int_rate, probs = 0.75) - 
  quantile(x = int_rate, probs = 0.25) 
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
```{r, iqr-2, tidy=FALSE}
## IQR()
IQR(int_rate)  
## summary() to get the numeric summary
summary(int_rate)
```
:::
::::

:::{.callout-note icon=false}
## Does a larger IQR means more or less variation?
:::

----------------------------------------------------------------

<span style="color:blue"> **Variance and Standard Deviation** </span>

-  The distance of an observation from its mean, $x_i - \overline{x}$, is its **deviation**.
- **Sample Variance** is defined as $$ s^2 = \frac{\sum_{i=1}^n(x_i - \overline{x})^2}{n-1} $$
- **Sample Standard Deviation (SD)** is defined as the square root of the variance.
$$ s = \sqrt{\frac{\sum_{i=1}^n(x_i - \overline{x})^2}{n-1}} $$
- The corresponding population variance and SD are denoted as $\sigma^2$ and $\sigma$ respectively.
- The variance is the average of squared deviation from the sample mean $\overline{x}$ or the **mean squared deviation** from the mean.
- The standard deviation is the **root mean squared deviation** from the mean. 
  - It measures, on average, **how far the data spread out around the average**.

<span style="color:red"> ***Compute Variance and SD in R*** </span>

```{r}
var(int_rate)
sqrt(var(int_rate))
sd(int_rate)
```


## Visualizing Data Variation

<span style="color:blue"> **Boxplot** </span>

- When plotting the whiskers for a boxplot,
  - the minimum is the minimal value that is not a potential outlier.
  - the maximum is the maximal value that is not a potential outlier.

```{r, out.width="80%", echo=FALSE, purl=FALSE}
#| label: fig-boxplot
#| fig-cap: Example of a boxplot (https://www.leansigmacorporation.com/box-plot-with-minitab/)
knitr::include_graphics("./images/img-data/boxplot.png")
```


<span style="color:red"> ***Interest Rate Boxplot*** </span>

- Below is the boxplot for the interest rate data (@fig-boxplot-interest).

```{r, echo=FALSE, out.width="75%", cache=TRUE, purl=FALSE, fig.align='center'}
#| label: fig-boxplot-interest
#| fig-cap: Boxplot for interest rate example
par(mar = c(0, 4, 0, 0))
par(mfrow = c(1, 1))
the.seed <- 2
openintro::boxPlot(int_rate,
        ylab = 'Interest Rate',
        xlim = c(0.3, 3),
        axes = FALSE,
        ylim = range(int_rate) + sd(int_rate) * c(-1, 1) * 0.2)
openintro::AxisInPercent(2, c(0, pretty(int_rate)), las = 1)
arrows(2, min(int_rate) + 1, 1.35, min(int_rate), length = 0.08)
text(2, min(int_rate) + 1, 'lower whisker (min)', pos = 4)
arrows(2, quantile(int_rate, 0.25) + sd(int_rate) / 7,
       1.35, quantile(int_rate, 0.25),
       length = 0.08)
text(2, quantile(int_rate, 0.25) + sd(int_rate) / 6.5,
     expression(Q[1]~~'(first quartile)'), pos = 4)
m <- median(int_rate)
arrows(2, m + sd(int_rate) / 5, 1.35, m, length = 0.08)
text(2,m + sd(int_rate) / 4.7, 'median', pos = 4)

q <- quantile(int_rate, 0.75)
arrows(2, q + sd(int_rate) / 4, 1.35, q, length = 0.08)
text(2, q + sd(int_rate) / 3.8,
     expression(Q[3]~~'(third quartile)'), pos = 4)

arrows(2, rev(sort(int_rate))[3] - sd(int_rate) / 4,
       1.35, rev(sort(int_rate))[3], length = 0.08)
text(2, rev(sort(int_rate))[3] - sd(int_rate) / 3.8,
     'upper whisker', pos = 4)

y <- quantile(int_rate, 0.75) + 1.5 * IQR(int_rate)
arrows(2, y - 0.1 * sd(int_rate),
       1.35, y, length = 0.08)
lines(c(0.72, 1.28), rep(y, 2),
      lty = 3, col = '#00000066')
text(2, y - 0.1 * sd(int_rate),
     'max whisker reach', pos = 4)
text(2, y + 0.05 * sd(int_rate),
     'Q3 + 1.5 IQR', pos = 4)

m <- rev(tail(sort(int_rate), 5))
s <- m[1] - 0.3 * sd(m)
arrows(2, s, 1.1, m[1] - 0.2, length = 0.08)
arrows(2, s, 1.1, m[2] + 0.3, length = 0.08)
text(2, s, 'suspected outliers', pos = 4)

set.seed(the.seed)
pt.jitter <- 0.05
nco <- 50
cutoffs <- seq(0.9 * min(int_rate), max(int_rate), length.out = nco)
for (i in 2:nco) {
  these <- which(cutoffs[i - 1] < int_rate & int_rate <= cutoffs[i])
  lt <- length(these)
  if (lt == 0) {
    next
  }
  x <- pt.jitter * (1:lt)
  x <- x - mean(x)
  points(rep(0.4, lt) + x, int_rate[these],
      col = rep(COL[1, 3], 25), pch = 19)
}
```


<span style="color:red"> ***Boxplot in R*** </span>

::::{.columns}
:::{.column width="49%"}
```{r boxplot, echo=-c(1, 2), out.width="100%"}
par(mar = c(0,4,0,0))
par(mfrow = c(1, 1))
boxplot(int_rate,ylab ="Interest Rate (%)")
```
:::

:::{.column width="2%"}
:::

:::{.column width="49%"}
```{r}
sort(int_rate, decreasing = TRUE)[1:5]
sort(int_rate)[1:5]
Q3 <- quantile(int_rate, probs = 0.75, 
               names = FALSE)
Q1 <- quantile(int_rate, probs = 0.25, 
               names = FALSE)
IQR <- Q3 - Q1
Q1 - 1.5 * IQR
Q3 + 1.5 * IQR
```
:::
::::

## Exercises

1. In the following, we will be using the data set `mtcars` to do some data summary and graphics. First load the data set into your R session by the command `data(mtcars)`. The data set is like
```{r}
head(mtcars)
```
Please see `?mtcars` for the description of the data set.

(a) Use the function `boxplot()` to generate a boxplot of 1/4 mile time (`qsec`). Are there any outliers?

(b) Compute the mean, median and standard deviation of displacement (`disp`).

2. **Mean and standard deviation (SD)**: For each part, compare data (1) and (2) based on their mean and SDs. You don't need to calculate these statistics, but compare (1) and (2) by stating which one has a larger mean/SD or they have the same mean/SD. Explain your reasoning.
    (a) (1) -30, 0, 0, 0, 15, 25, 25
        (2) -50, 0, 0, 0, 15, 20, 25  
    (b) (1) 0, 1, 3, 5, 7
        (2) 21, 23, 25, 27, 29  
    (c) (1) 100, 200, 300, 400, 500
        (2) 0, 50, 350, 500, 600
        
3. **Skewness**: Facebook data indicate that $50\%$ of Facebook users have 130 or more friends, and that the average friend count of users is 115. What do these findings suggest about the shape (right-skewed, left-skewed, symmetric) of the distribution of number of friends of Facebook users? Please explain.