[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Statistics",
    "section": "",
    "text": "This is the website for my introductory statistics book. This book serves as a main reference book for my MATH 4720 Statistical Methods and MATH 4740 Biostatistical Methods at Marquette University.1 Some topics can also be discussed in an introductory data science course. You’ll learn basic probability and statistical concepts as well as data analysis techniques such as linear regression using R computing software. The book balances the following aspects of statistics:\n\nmathematical derivation and statistical computation\ndistribution-based and simulation-based inferences\nmethodology and applications\nclassical/frequentist and Bayesian approaches\n\nCourse materials are borrowed from the following books:\n\nOpenIntro Statsitics (data oriented)\nIntroduction to Modern Statistics (computation oriented)\nAn Introduction to Statistical Methods & Data Analysis, 7th edition (mathematics oriented)"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Statistics and Data",
    "section": "",
    "text": "What is Statistics? What is Data Science? What are data?"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "13  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "Introduction to Statistics",
    "section": "License",
    "text": "License\nThis website is (and will always be) free to use, and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 4.0 License. If you’d like to give back, please consider reporting a typo or leaving a pull request at github.com/chenghanyustats/introstatsbook."
  },
  {
    "objectID": "intro-stats.html",
    "href": "intro-stats.html",
    "title": "1  Science of Data and Data Science",
    "section": "",
    "text": "In ordinary conversations, the word statistics is used as a term to indicate a set or collection of numeric records. as shown in Figure 1.1\nInterestingly someone defines statistics as the only field where two experts, using identical data, may come to completely opposite conclusions Figure 1.2, which is true in some sense. And we’ll see why later in this course. With the same data, different statistical methods may produce different results and lead to difference conclusions."
  },
  {
    "objectID": "intro-stats.html#the-r-user-interface",
    "href": "intro-stats.html#the-r-user-interface",
    "title": "1  What is Statistics",
    "section": "1.1 The R User Interface",
    "text": "1.1 The R User Interface\nBefore you can ask your computer to save some numbers, you’ll need to know how to talk to it. That’s where R and RStudio come in. RStudio gives you a way to talk to your computer. R gives you a language to speak in. To get started, open RStudio just as you would open any other application on your computer. When you do, a window should appear in your screen like the one shown in ?fig-console.\n\n\n\n\n\n\n\nNote\n\n\n\nIf you do not yet have R and RStudio installed on your computer–or do not know what I am talking about–visit Appendix A. The appendix will give you an overview of the two free tools and tell you how to download them.\n\n\nThe RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a command, because it will command your computer to do something for you. The line you type it into is called the command line.\nWhen you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type 1 + 1 and hit Enter, RStudio will display:\n> 1 + 1\n[1] 2\n>\nYou’ll notice that a [1] appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command 100:130 returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:\n> 100:130\n [1] 100 101 102 103 104 105 106 107 108 109 110 111 112\n[14] 113 114 115 116 117 118 119 120 121 122 123 124 125\n[25] 126 127 128 129 130\n\n\n\n\n\n\nTip\n\n\n\nThe colon operator (:) returns every integer between two integers. It is an easy way to create a sequence of numbers.\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou may hear me speak of R in the third person. For example, I might say, “Tell R to do this” or “Tell R to do that”, but of course R can’t do anything; it is just a language. This way of speaking is shorthand for saying, “Tell your computer to do this by writing a command in the R language at the command line of your RStudio console.” Your computer, and not R, does the actual work.\nIs this shorthand confusing and slightly lazy to use? Yes. Do a lot of people use it? Everyone I know–probably because it is so convenient.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.\n\n\nIf you type an incomplete command and press Enter, R will display a + prompt, which means R is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:\n> 5 -\n+\n+ 1\n[1] 4\nIf you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:\n> 3 % 5\nError: unexpected input in \"3 % 5\"\n>\nOnce you get the hang of the command line, you can easily do anything in R that you would do with a calculator. For example, you could do some basic arithmetic:\n2 * 3   \n## 6\n\n4 - 1   \n## 3\n\n6 / (4 - 1)   \n## 2\nDid you notice something different about this code? I’ve left out the >’s and [1]’s. This will make the code easier to copy and paste if you want to put it in your own console.\nR treats the hashtag character, #, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the commenting symbol in R.\nFor the remainder of the book, I’ll use hashtags to display the output of R code. I’ll use a single hashtag to add my own comments and a double hashtag, ##, to display the results of code. I’ll avoid showing >s and [1]s unless I want you to look at them.\n\n\n\n\n\n\nImportant\n\n\n\nSome R commands may take a long time to run. You can cancel a command once it has begun by pressing ctrl + c. Note that it may also take R a long time to cancel the command.\n\n\n\n\n\n\n\n\nExercise: Magic with Numbers\n\n\n\nThat’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:\n\nChoose any number and add 2 to it.\nMultiply the result by 3.\nSubtract 6 from the answer.\nDivide what you get by 3.\n\n\n\nThroughout the book, I’ll put exercises in chunks, like the one above. I’ll follow each exercise with a model answer, like the one below.\nYou could start with the number 10, and then do the following steps:\n10 + 2\n## 12\n\n12 * 3\n## 36\n\n36 - 6\n## 30\n\n30 / 3\n## 10"
  },
  {
    "objectID": "intro-data.html",
    "href": "intro-data.html",
    "title": "2  Data",
    "section": "",
    "text": "Data: A set of objects on which we observe or measure one or more characteristics.\nObjects are individuals, observations, subjects or cases in statistical studies.\nA characteristic or attribute is called a variable because it varies from one to another.\n\n\n\n\n\n\n\n\n\n\n\nAll right. Statistics is a Science of Data, so What is Data?\nLet’s define Data.\nA data set is a set of objects on which we observe or measure one or more characteristics.\nObjects are individuals, observations, subjects or cases in statistical studies.\nA characteristic or attribute is called a variable because it varies from one to another.\nFor example, the data set right here is a set of Marquette basketball players.\nSo objects are individuals or players in the data.\nAnd each player has several characteristics or attributes shown in columns associated with him.\nFor example, his #, class, position, height, weight, hometown, and high school.\nThese characteristics are called variables because they vary form one to another. Clear?"
  },
  {
    "objectID": "intro-data.html#the-r-user-interface",
    "href": "intro-data.html#the-r-user-interface",
    "title": "2  Data",
    "section": "2.1 The R User Interface",
    "text": "2.1 The R User Interface"
  },
  {
    "objectID": "intro-r.html",
    "href": "intro-r.html",
    "title": "3  Tool foR Data",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "intro-r.html#the-r-user-interface",
    "href": "intro-r.html#the-r-user-interface",
    "title": "3  Tool foR Data",
    "section": "3.1 The R User Interface",
    "text": "3.1 The R User Interface"
  },
  {
    "objectID": "data-graphics.html",
    "href": "data-graphics.html",
    "title": "4  Data Visualization",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "data-graphics.html#the-r-user-interface",
    "href": "data-graphics.html#the-r-user-interface",
    "title": "4  Data Visualization",
    "section": "4.1 The R User Interface",
    "text": "4.1 The R User Interface"
  },
  {
    "objectID": "data-numerics.html",
    "href": "data-numerics.html",
    "title": "5  Data Sample Statistics",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "data-numerics.html#the-r-user-interface",
    "href": "data-numerics.html#the-r-user-interface",
    "title": "5  Data Sample Statistics",
    "section": "5.1 The R User Interface",
    "text": "5.1 The R User Interface"
  },
  {
    "objectID": "datasummary.html",
    "href": "datasummary.html",
    "title": "Summarizing Data",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "datasummary.html#the-r-user-interface",
    "href": "datasummary.html#the-r-user-interface",
    "title": "Summarizing Data",
    "section": "The R User Interface",
    "text": "The R User Interface"
  },
  {
    "objectID": "intro-stats.html#objects",
    "href": "intro-stats.html#objects",
    "title": "1  What is Statistics",
    "section": "1.2 Objects",
    "text": "1.2 Objects\nNow that you know how to use R, let’s use it to make a virtual die. The : operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The : operator returns its results as a vector, a one-dimensional set of numbers:\n1:6\n## 1 2 3 4 5 6\nThat’s all there is to how a virtual die looks! But you are not done yet. Running 1:6 generated a vector of numbers for you to see, but it didn’t save that vector anywhere in your computer’s memory. What you are looking at is basically the footprints of six numbers that existed briefly and then melted back into your computer’s RAM. If you want to use those numbers again, you’ll have to ask your computer to save them somewhere. You can do that by creating an R object.\nR lets you save data by storing it inside an R object. What is an object? Just a name that you can use to call up stored data. For example, you can save data into an object like a or b. Wherever R encounters the object, it will replace it with the data saved inside, like so:\na <- 1\na\n## 1\n\na + 2\n## 3\n\n\n\n\n\n\nNote\n\n\n\n\nTo create an R object, choose a name and then use the less-than symbol, <, followed by a minus sign, -, to save data into it. This combination looks like an arrow, <-. R will make an object, give it your name, and store in it whatever follows the arrow. So a <- 1 stores 1 in an object named a.\nWhen you ask R what’s in a, R tells you on the next line.\nYou can use your object in new R commands, too. Since a previously stored the value of 1, you’re now adding 1 to 2.\n\n\n\nSo, for another example, the following code would create an object named die that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:\ndie <- 1:6\n\ndie\n## 1 2 3 4 5 6\nWhen you create an object, the object will appear in the environment pane of RStudio, as shown in ?fig-environment. This pane will show you all of the objects you’ve created since opening RStudio.\n\nYou can name an object in R almost anything you want, but there are a few rules. First, a name cannot start with a number. Second, a name cannot use some special symbols, like ^, !, $, @, +, -, /, or *:\n\n\n\nGood names\nNames that cause errors\n\n\n\n\na\n1trial\n\n\nb\n$\n\n\nFOO\n^mean\n\n\nmy_var\n2nd\n\n\n.day\n!bad\n\n\n\n\n\n\n\n\n\nCapitalization\n\n\n\nR is case-sensitive, so name and Name will refer to different objects:\nName <- 1\nname <- 0  \n  \nName + 1  \n## 2  \n\n\nFinally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to not use names that are already taken:\nmy_number <- 1\nmy_number \n## 1\n\nmy_number <- 999\nmy_number\n## 999\nYou can see which object names you have already used with the function ls:\nls()\n## \"a\"         \"die\"       \"my_number\" \"name\"     \"Name\"     \nYou can also see which names you have used by examining RStudio’s environment pane.\nYou now have a virtual die that is stored in your computer’s memory. You can access it whenever you like by typing the word die. So what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist. So let’s take a look at how to do that:\ndie - 1\n## 0 1 2 3 4 5\n\ndie / 2\n## 0.5 1.0 1.5 2.0 2.5 3.0\n\ndie * die\n## 1  4  9 16 25 36\nIf you are a big fan of linear algebra (and who isn’t?), you may notice that R does not always follow the rules of matrix multiplication. Instead, R uses element-wise execution. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run die - 1, R subtracts one from each element of die.\nWhen you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run die * die, R lines up the two die vectors and then multiplies the first element of vector 1 by the first element of vector 2. R then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two, as shown in ?fig-elementwise.\n\nIf you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in Figure 1.4. This isn’t a permanent change–the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message. This behavior is known as vector recycling, and it helps R do element-wise operations:\n1:2\n## 1 2\n\n1:4\n## 1 2 3 4\n\ndie\n## 1 2 3 4 5 6\n\ndie + 1:2\n## 2 4 4 6 6 8\n\ndie + 1:4\n## 2 4 6 8 6 8\nWarning message:\nIn die + 1:4 :\n  longer object length is not a multiple of shorter object length\n\n\n\nFigure 1.4: R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.\n\n\nElement-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.\nBut don’t think that R has given up on traditional matrix multiplication. You just have to ask for it when you want it. You can do inner multiplication with the %*% operator and outer multiplication with the %o% operator:\ndie %*% die\n## 91\n\ndie %o% die\n##      [,1] [,2] [,3] [,4] [,5] [,6]\n## [1,]    1    2    3    4    5    6\n## [2,]    2    4    6    8   10   12\n## [3,]    3    6    9   12   15   18\n## [4,]    4    8   12   16   20   24\n## [5,]    5   10   15   20   25   30\n## [6,]    6   12   18   24   30   36\nYou can also do things like transpose a matrix with t and take its determinant with det.\nDon’t worry if you’re not familiar with these operations. They are easy to look up, and you won’t need them for this book.\nNow that you can do math with your die object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a function."
  },
  {
    "objectID": "intro-stats.html#functions",
    "href": "intro-stats.html#functions",
    "title": "1  What is Statistics",
    "section": "1.3 Functions",
    "text": "1.3 Functions\nR comes with many functions that you can use to do sophisticated tasks like random sampling. For example, you can round a number with the round function, or calculate its factorial with the factorial function. Using a function is pretty simple. Just write the name of the function and then the data you want the function to operate on in parentheses:\nround(3.1415)\n## 3\n\nfactorial(3)\n## 6\nThe data that you pass into the function is called the function’s argument. The argument can be raw data, an R object, or even the results of another R function. In this last case, R will work from the innermost function to the outermost, as in ?fig-pemdas.\nmean(1:6)\n## 3.5\n\nmean(die)\n## 3.5\n\nround(mean(die))\n## 4\n\nLucky for us, there is an R function that can help “roll” the die. You can simulate a roll of the die with R’s sample function. sample takes two arguments: a vector named x and a number named size. sample will return size elements from the vector:\nsample(x = 1:4, size = 2)\n## 3 2\nTo roll your die and get a number back, set x to die and sample one element from it. You’ll get a new (maybe different) number each time you roll it:\nsample(x = die, size = 1)\n## 2\n\nsample(x = die, size = 1)\n## 1\n\nsample(x = die, size = 1)\n## 6\nMany R functions take multiple arguments that help them do their job. You can give a function as many arguments as you like as long as you separate each argument with a comma.\nYou may have noticed that I set die and 1 equal to the names of the arguments in sample, x and size. Every argument in every R function has a name. You can specify which data should be assigned to which argument by setting a name equal to data, as in the preceding code. This becomes important as you begin to pass multiple arguments to the same function; names help you avoid passing the wrong data to the wrong argument. However, using names is optional. You will notice that R users do not often use the name of the first argument in a function. So you might see the previous code written as:\nsample(die, size = 1)\n## 2\nOften, the name of the first argument is not very descriptive, and it is usually obvious what the first piece of data refers to anyways.\nBut how do you know which argument names to use? If you try to use a name that a function does not expect, you will likely get an error:\nround(3.1415, corners = 2)\n## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)\nIf you’re not sure which names to use with a function, you can look up the function’s arguments with args. To do this, place the name of the function in the parentheses behind args. For example, you can see that the round function takes two arguments, one named x and one named digits:\nargs(round)\n## function (x, digits = 0) \n## NULL\nDid you notice that args shows that the digits argument of round is already set to 0? Frequently, an R function will take optional arguments like digits. These arguments are considered optional because they come with a default value. You can pass a new value to an optional argument if you want, and R will use the default value if you do not. For example, round will round your number to 0 digits past the decimal point by default. To override the default, supply your own value for digits:\nround(3.1415)\n## 3\n\nround(3.1415, digits = 2)\n## 3.14\nYou should write out the names of each argument after the first one or two when you call a function with multiple arguments. Why? First, this will help you and others understand your code. It is usually obvious which argument your first input refers to (and sometimes the second input as well). However, you’d need a large memory to remember the third and fourth arguments of every R function. Second, and more importantly, writing out argument names prevents errors.\nIf you do not write out the names of your arguments, R will match your values to the arguments in your function by order. For example, in the following code, the first value, die, will be matched to the first argument of sample, which is named x. The next value, 1, will be matched to the next argument, size:\nsample(die, 1)\n## 2\nAs you provide more arguments, it becomes more likely that your order and R’s order may not align. As a result, values may get passed to the wrong argument. Argument names prevent this. R will always match a value to its argument name, no matter where it appears in the order of arguments:\nsample(size = 1, x = die)\n## 2\n\n1.3.1 Sample with Replacement\nIf you set size = 2, you can almost simulate a pair of dice. Before we run that code, think for a minute why that might be the case. sample will return two numbers, one for each die:\nsample(die, size = 2)\n## 3 4\nI said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?\nBy default, sample builds a sample without replacement. To see what this means, imagine that sample places all of the values of die in a jar or urn. Then imagine that sample reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, sample sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if sample selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although sample creates its sample electronically, it follows this seemingly physical behavior.\nOne side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in sample by adding the argument replace = TRUE:\nsample(die, size = 2, replace = TRUE)\n## 5 5\nThe argument replace = TRUE causes sample to sample with replacement. Our jar example provides a good way to understand the difference between sampling with replacement and without. When sample uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, sample replaces each value after each draw. As a result, sample may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.\nSampling with replacement is an easy way to create independent random samples. Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:\nsample(die, size = 2, replace = TRUE)\n## 2 4\nCongratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice. If you want to add up the dice, you can feed your result straight into the sum function:\ndice <- sample(die, size = 2, replace = TRUE)\ndice\n## 2 4\n\nsum(dice)\n## 6\nWhat would happen if you call dice multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:\ndice\n## 2 4\n\ndice\n## 2 4\n\ndice\n## 2 4\nNope. Each time you call dice, R will show you the result of that one time you called sample and saved the output to dice. R won’t rerun sample(die, 2, replace = TRUE) to create a new roll of the dice. This is a relief in a way. Once you save a set of results to an R object, those results do not change. Programming would be quite hard if the values of your objects changed each time you called them.\nHowever, it would be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function."
  },
  {
    "objectID": "intro-stats.html#sec-write-functions",
    "href": "intro-stats.html#sec-write-functions",
    "title": "1  What is Statistics",
    "section": "1.4 Writing Your Own Functions",
    "text": "1.4 Writing Your Own Functions\nTo recap, you already have working R code that simulates rolling a pair of dice:\ndie <- 1:6\ndice <- sample(die, size = 2, replace = TRUE)\nsum(dice)\nYou can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named roll that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call roll(), R will return the sum of rolling two dice:\nroll()\n## 8 \n\nroll()\n## 3\n\nroll()\n## 7\nFunctions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.\n\n1.4.1 The Function Constructor\nEvery function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the function function. To do this, call function() and follow it with a pair of braces, {}:\nmy_function <- function() {}\nfunction will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\n\n\n\n\n\n\nNote\n\n\n\nNotice that I indented each line of code between the braces. This makes the code easier for you and me to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time.\n\n\nJust hit the Enter key between each line after the first brace, {. R will wait for you to type the last brace, }, before it responds.\nDon’t forget to save the output of function to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:\nroll()\n## 9\nYou can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name without the parentheses, R will show you the code that is stored inside the function. If you type in the name with the parentheses, R will run that code:\nroll\n## function() {\n##   die <- 1:6\n##   dice <- sample(die, size = 2, replace = TRUE)\n##   sum(dice)\n## }\n\nroll()\n## 6\nThe code that you place inside your function is known as the body of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?\nHere’s some code that would display a result:\ndice\n1 + 1\nsqrt(2)\nAnd here’s some code that would not:\ndice <- sample(die, size = 2, replace = TRUE)\ntwo <- 1 + 1\na <- sqrt(2)\nDo you notice the pattern? These lines of code do not return a value to the command line; they save a value to an object."
  },
  {
    "objectID": "intro-stats.html#arguments",
    "href": "intro-stats.html#arguments",
    "title": "1  What is Statistics",
    "section": "1.5 Arguments",
    "text": "1.5 Arguments\nWhat if we removed one line of code from our function and changed the name die to bones, like this?\nroll2 <- function() {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow I’ll get an error when I run the function. The function needs the object bones to do its job, but there is no object named bones to be found:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   object 'bones' not found\nYou can supply bones when you call roll2 if you make bones an argument of the function. To do this, put the name bones in the parentheses that follow function when you define roll2:\nroll2 <- function(bones) {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow roll2 will work as long as you supply bones when you call the function. You can take advantage of this to roll different types of dice each time you call roll2. Dungeons and Dragons, here we come!\nRemember, we’re rolling pairs of dice:\nroll2(bones = 1:4)\n##  3\n\nroll2(bones = 1:6)\n## 10\n\nroll2(1:20)\n## 31\nNotice that roll2 will still give an error if you do not supply a value for the bones argument when you call roll2:\nroll2()\n## Error in sample(bones, size = 2, replace = TRUE) : \n##   argument \"bones\" is missing, with no default\nYou can prevent this error by giving the bones argument a default value. To do this, set bones equal to a value when you define roll2:\nroll2 <- function(bones = 1:6) {\n  dice <- sample(bones, size = 2, replace = TRUE)\n  sum(dice)\n}\nNow you can supply a new value for bones if you like, and roll2 will use the default if you do not:\nroll2()\n## 9\nYou can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow function. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).\nTo summarize, function helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow function. You create arguments for your function to use by supplying their names in the parentheses that follow function. Finally, you give your function a name by saving its output to an R object, as shown in ?fig-functions.\nOnce you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like. Project 3: Slot Machine will teach you much more about writing functions in R."
  },
  {
    "objectID": "intro-stats.html#scripts",
    "href": "intro-stats.html#scripts",
    "title": "1  What is Statistics",
    "section": "1.6 Scripts",
    "text": "1.6 Scripts\nWhat if you want to edit roll2 again? You could go back and retype each line of code in roll2, but it would be so much easier if you had a draft of the code to start from. You can create a draft of your code as you go by using an R script. An R script is just a plain text file that you save R code in. You can open an R script in RStudio by going to File > New File > R script in the menu bar. RStudio will then open a fresh script above your console pane, as shown in ?fig-script.\nI strongly encourage you to write and edit all of your R code in a script before you run it in the console. Why? This habit creates a reproducible record of your work. When you’re finished for the day, you can save your script and then use it to rerun your entire analysis the next day. Scripts are also very handy for editing and proofreading your code, and they make a nice copy of your work to share with others. To save a script, click the scripts pane, and then go to File > Save As in the menu bar.\n\nRStudio comes with many built-in features that make it easy to work with scripts. First, you can automatically execute a line of code in a script by clicking the Run button, as shown in ?fig-run.\nR will run whichever line of code your cursor is on. If you have a whole section highlighted, R will run the highlighted code. Alternatively, you can run the entire script by clicking the Source button. Don’t like clicking buttons? You can use Control + Return as a shortcut for the Run button. On Macs, that would be Command + Return.\n\nIf you’re not convinced about scripts, you soon will be. It becomes a pain to write multi-line code in the console’s single-line command line. Let’s avoid that headache and open your first script now before we move to the next chapter.\n\n\n\n\n\n\nExtract function\n\n\n\nRStudio comes with a tool that can help you build functions. To use it, highlight the lines of code in your R script that you want to turn into a function. Then click Code > Extract Function in the menu bar. RStudio will ask you for a function name to use and then wrap your code in a function call. It will scan the code for undefined variables and use these as arguments.\nYou may want to double-check RStudio’s work. It assumes that your code is correct, so if it does something surprising, you may have a problem in your code."
  },
  {
    "objectID": "intro-stats.html#summary",
    "href": "intro-stats.html#summary",
    "title": "1  What is Statistics",
    "section": "1.7 Summary",
    "text": "1.7 Summary\nYou’ve covered a lot of ground already. You now have a virtual die stored in your computer’s memory, as well as your own R function that rolls a pair of dice. You’ve also begun speaking the R language.\nAs you’ve seen, R is a language that you can use to talk to your computer. You write commands in R and run them at the command line for your computer to read. Your computer will sometimes talk back–for example, when you commit an error–but it usually just does what you ask and then displays the result.\nThe two most important components of the R language are objects, which store data, and functions, which manipulate data. R also uses a host of operators like +, -, *, /, and <- to do basic tasks. As a data scientist, you will use R objects to store data in your computer’s memory, and you will use functions to automate tasks and do complicated calculations. We will examine objects in more depth later in Project 2: Playing Cards and dig further into functions in Project 3: Slot Machine. The vocabulary you have developed here will make each of those projects easier to understand. However, we’re not done with your dice yet.\nIn Packages and Help Pages, you’ll run some simulations on your dice and build your first graphs in R. You’ll also look at two of the most useful components of the R language: R packages, which are collections of functions writted by R’s talented community of developers, and R documentation, which is a collection of help pages built into R that explains every function and data set in the language."
  },
  {
    "objectID": "prob.html",
    "href": "prob.html",
    "title": "Probability",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob.html#the-r-user-interface",
    "href": "prob.html#the-r-user-interface",
    "title": "Probability",
    "section": "The R User Interface",
    "text": "The R User Interface"
  },
  {
    "objectID": "prob-define.html",
    "href": "prob-define.html",
    "title": "6  Definition of Probability",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-define.html#the-r-user-interface",
    "href": "prob-define.html#the-r-user-interface",
    "title": "6  Definition of Probability",
    "section": "6.1 The R User Interface",
    "text": "6.1 The R User Interface"
  },
  {
    "objectID": "prob-rule.html",
    "href": "prob-rule.html",
    "title": "7  Probability Rules",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-rule.html#the-r-user-interface",
    "href": "prob-rule.html#the-r-user-interface",
    "title": "7  Probability Rules",
    "section": "7.1 The R User Interface",
    "text": "7.1 The R User Interface"
  },
  {
    "objectID": "prob-rv.html",
    "href": "prob-rv.html",
    "title": "8  Random Variables",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-rv.html#the-r-user-interface",
    "href": "prob-rv.html#the-r-user-interface",
    "title": "8  Random Variables",
    "section": "8.1 The R User Interface",
    "text": "8.1 The R User Interface"
  },
  {
    "objectID": "prob-disc.html",
    "href": "prob-disc.html",
    "title": "9  Discrete Probability Distributions",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-disc.html#the-r-user-interface",
    "href": "prob-disc.html#the-r-user-interface",
    "title": "9  Discrete Probability Distributions",
    "section": "9.1 The R User Interface",
    "text": "9.1 The R User Interface"
  },
  {
    "objectID": "prob-cont.html",
    "href": "prob-cont.html",
    "title": "10  Continuous Probability Distributions",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-cont.html#the-r-user-interface",
    "href": "prob-cont.html#the-r-user-interface",
    "title": "10  Continuous Probability Distributions",
    "section": "10.1 The R User Interface",
    "text": "10.1 The R User Interface"
  },
  {
    "objectID": "prob-samdist.html",
    "href": "prob-samdist.html",
    "title": "11  Sampling Distribution",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-samdist.html#the-r-user-interface",
    "href": "prob-samdist.html#the-r-user-interface",
    "title": "11  Sampling Distribution",
    "section": "11.1 The R User Interface",
    "text": "11.1 The R User Interface"
  },
  {
    "objectID": "prob-llnclt.html",
    "href": "prob-llnclt.html",
    "title": "12  Law of Large Numbers and Central Limit Theorem",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "prob-llnclt.html#the-r-user-interface",
    "href": "prob-llnclt.html#the-r-user-interface",
    "title": "12  Law of Large Numbers and Central Limit Theorem",
    "section": "12.1 The R User Interface",
    "text": "12.1 The R User Interface"
  },
  {
    "objectID": "infer.html",
    "href": "infer.html",
    "title": "Statistical Inference",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer.html#the-r-user-interface",
    "href": "infer.html#the-r-user-interface",
    "title": "Statistical Inference",
    "section": "The R User Interface",
    "text": "The R User Interface"
  },
  {
    "objectID": "infer-ci.html",
    "href": "infer-ci.html",
    "title": "13  Confidence Interval",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-ci.html#the-r-user-interface",
    "href": "infer-ci.html#the-r-user-interface",
    "title": "13  Confidence Interval",
    "section": "13.1 The R User Interface",
    "text": "13.1 The R User Interface"
  },
  {
    "objectID": "infer-bt.html",
    "href": "infer-bt.html",
    "title": "14  Bootstrapping",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-bt.html#the-r-user-interface",
    "href": "infer-bt.html#the-r-user-interface",
    "title": "14  Bootstrapping",
    "section": "14.1 The R User Interface",
    "text": "14.1 The R User Interface"
  },
  {
    "objectID": "infer-ht.html",
    "href": "infer-ht.html",
    "title": "15  Hypothesis Testing",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-ht.html#the-r-user-interface",
    "href": "infer-ht.html#the-r-user-interface",
    "title": "15  Hypothesis Testing",
    "section": "15.1 The R User Interface",
    "text": "15.1 The R User Interface"
  },
  {
    "objectID": "infer-twomean.html",
    "href": "infer-twomean.html",
    "title": "16  Comparing Two Population Means",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-twomean.html#the-r-user-interface",
    "href": "infer-twomean.html#the-r-user-interface",
    "title": "16  Comparing Two Population Means",
    "section": "16.1 The R User Interface",
    "text": "16.1 The R User Interface"
  },
  {
    "objectID": "infer-var.html",
    "href": "infer-var.html",
    "title": "17  Inference About Variances",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-var.html#the-r-user-interface",
    "href": "infer-var.html#the-r-user-interface",
    "title": "17  Inference About Variances",
    "section": "17.1 The R User Interface",
    "text": "17.1 The R User Interface"
  },
  {
    "objectID": "infer-prop.html",
    "href": "infer-prop.html",
    "title": "18  Inference About Proportions",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-prop.html#the-r-user-interface",
    "href": "infer-prop.html#the-r-user-interface",
    "title": "18  Inference About Proportions",
    "section": "18.1 The R User Interface",
    "text": "18.1 The R User Interface"
  },
  {
    "objectID": "infer-goodnessfit.html",
    "href": "infer-goodnessfit.html",
    "title": "19  Test of Goodness of Fit",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-goodnessfit.html#the-r-user-interface",
    "href": "infer-goodnessfit.html#the-r-user-interface",
    "title": "19  Test of Goodness of Fit",
    "section": "19.1 The R User Interface",
    "text": "19.1 The R User Interface"
  },
  {
    "objectID": "infer-indep.html",
    "href": "infer-indep.html",
    "title": "20  Test of Independence",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-indep.html#the-r-user-interface",
    "href": "infer-indep.html#the-r-user-interface",
    "title": "20  Test of Independence",
    "section": "20.1 The R User Interface",
    "text": "20.1 The R User Interface"
  },
  {
    "objectID": "infer-bayes.html",
    "href": "infer-bayes.html",
    "title": "21  Bayesian Inference",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-bayes.html#the-r-user-interface",
    "href": "infer-bayes.html#the-r-user-interface",
    "title": "21  Bayesian Inference",
    "section": "21.1 The R User Interface",
    "text": "21.1 The R User Interface"
  },
  {
    "objectID": "infer-nonpar.html",
    "href": "infer-nonpar.html",
    "title": "22  Nonparametric Inference",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "infer-nonpar.html#the-r-user-interface",
    "href": "infer-nonpar.html#the-r-user-interface",
    "title": "22  Nonparametric Inference",
    "section": "22.1 The R User Interface",
    "text": "22.1 The R User Interface"
  },
  {
    "objectID": "model.html",
    "href": "model.html",
    "title": "Statistical Models",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model.html#the-r-user-interface",
    "href": "model.html#the-r-user-interface",
    "title": "Statistical Models",
    "section": "The R User Interface",
    "text": "The R User Interface"
  },
  {
    "objectID": "model-anova.html",
    "href": "model-anova.html",
    "title": "23  Analysis of Variance",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model-anova.html#the-r-user-interface",
    "href": "model-anova.html#the-r-user-interface",
    "title": "23  Analysis of Variance",
    "section": "23.1 The R User Interface",
    "text": "23.1 The R User Interface"
  },
  {
    "objectID": "model-reg.html",
    "href": "model-reg.html",
    "title": "24  Linear Regression",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model-reg.html#the-r-user-interface",
    "href": "model-reg.html#the-r-user-interface",
    "title": "24  Linear Regression",
    "section": "24.1 The R User Interface",
    "text": "24.1 The R User Interface"
  },
  {
    "objectID": "model-logistic.html",
    "href": "model-logistic.html",
    "title": "25  Logistic Regression",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model-logistic.html#the-r-user-interface",
    "href": "model-logistic.html#the-r-user-interface",
    "title": "25  Logistic Regression",
    "section": "25.1 The R User Interface",
    "text": "25.1 The R User Interface"
  },
  {
    "objectID": "model-bayes.html",
    "href": "model-bayes.html",
    "title": "26  Bayesian Linear Regression",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model-bayes.html#the-r-user-interface",
    "href": "model-bayes.html#the-r-user-interface",
    "title": "26  Bayesian Linear Regression",
    "section": "26.1 The R User Interface",
    "text": "26.1 The R User Interface"
  },
  {
    "objectID": "model-survival.html",
    "href": "model-survival.html",
    "title": "27  Survival Analysis",
    "section": "",
    "text": "This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.\nTo simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save information about the object in your computer’s memory.\nWhich information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.\nLet’s work on saving these numbers first, and then consider a method for “rolling” our die."
  },
  {
    "objectID": "model-survival.html#the-r-user-interface",
    "href": "model-survival.html#the-r-user-interface",
    "title": "27  Survival Analysis",
    "section": "27.1 The R User Interface",
    "text": "27.1 The R User Interface"
  },
  {
    "objectID": "intro-stats.html#statistics-as-a-discipline",
    "href": "intro-stats.html#statistics-as-a-discipline",
    "title": "1  Science of Data and Data Science",
    "section": "1.1 Statistics as a Discipline",
    "text": "1.1 Statistics as a Discipline\n\n\n\n\n\nFigure 1.3: Source: https://en.wikipedia.org/wiki/Statistics\n\n\n\n\n\nForget about that useless definition.\nFrom Wiki, Statistics is formally defined as the discipline that concerns the collection, organization, analysis, interpretation and presentation of data.\nStatistics is a Science of Data.\nSo, Statistics is a Science of Data.\nThere might be another science of data. I’m not saying statistics is THE science of data.\nA science of data using statistical thinking, methods and models.\nTo me, statistics is a science of data using statistical thinking and methods.\n\n🤔 But wait, then what is DATA SCIENCE ❓\n\nBut wait, if statistics is a science of data, then what is DATA SCIENCE?"
  },
  {
    "objectID": "intro-stats.html#difference-between-statistics-and-data-science",
    "href": "intro-stats.html#difference-between-statistics-and-data-science",
    "title": "1  Science of Data and Data Science",
    "section": "1.2 Difference between Statistics and Data Science",
    "text": "1.2 Difference between Statistics and Data Science\n\n\n\n\n\n\nFigure 1.4: Twits about what are data sicnece and data scientist\n\n\n\nInvestopedia defines Data Science is a field of applied mathematics and statistics that provides useful information based on large amounts of complex data or big data.\n\n\n\n\n\n\n\nFigure 1.5: Professor Ariely on big data\n\n\n\nBut Dan Ariely, a famous behavioral economist at Duke once said:\nSo What on earth is DS? Maybe nobody has the exactly correct answer."
  },
  {
    "objectID": "intro-stats.html#uc-santa-cruz-department-of-statistics-courses",
    "href": "intro-stats.html#uc-santa-cruz-department-of-statistics-courses",
    "title": "1  Science of Data and Data Science",
    "section": "1.3 UC Santa Cruz Department of Statistics Courses",
    "text": "1.3 UC Santa Cruz Department of Statistics Courses\n\n\n\n\n\nCourse offering of department of statistics at UC Santa Cruz. Source: https://courses.soe.ucsc.edu/\n\n\n\n\n\nHere shows statistics courses offered by UC Santa Cruz the university I graduated from.\nYou can see that statistics focus much more on data analysis, methods and models.\nThe stats department don’t talk much about on data collection, organization, and data presentation or data visualization."
  },
  {
    "objectID": "intro-stats.html#data-science-is-now-a-broader-view-of-statistics",
    "href": "intro-stats.html#data-science-is-now-a-broader-view-of-statistics",
    "title": "1  Science of Data and Data Science",
    "section": "1.4 Data Science Is Now a Broader View of Statistics",
    "text": "1.4 Data Science Is Now a Broader View of Statistics\n\nCollection, organization, analysis, interpretation and presentation of data.\n\n\n\n\n\n\nThe Data Science process. Created at Harvard by Joe Blitzstein and Hanspeter Pfister.\n\n\n\n\n\nAnd now data science is more like a broader view of statistics.\nBecause again, in usual statistics department, we don’t really teach or do much research on data collection, cleaning, storage, database management, and data visualization, which all are now a part of DS.\nStatistics focus very much on data analysis and modeling.\nAnyway, please don’t care about the names.\nThe important thing is, you learn useful methods to help you analyze your data.\nNo matter what it is called statistics or data science."
  },
  {
    "objectID": "intro-stats.html#what-do-we-learn-in-this-course",
    "href": "intro-stats.html#what-do-we-learn-in-this-course",
    "title": "1  Science of Data and Data Science",
    "section": "1.5 What Do We Learn In this Course",
    "text": "1.5 What Do We Learn In this Course\n\n\n\n\n\n\n\n\n\n\n\nIn particular, we will spend most of the time talking about probability and statistical inference methods OK."
  },
  {
    "objectID": "intro-stats.html#we-focus-on-statistical-inference",
    "href": "intro-stats.html#we-focus-on-statistical-inference",
    "title": "1  Science of Data and Data Science",
    "section": "1.6 We Focus On Statistical Inference",
    "text": "1.6 We Focus On Statistical Inference\n\nWe spend most of time on various statistical methods for analyzing data.\nLearn useful information\n\nabout the population we are interested\nfrom our sample data\nthrough statistical inferential methods, including estimation and testing\n\n\n\n\n\n\n\n\n\n\n\n\nIn fact, we like to learn some information or something useful\n\nabout the population we are interested\nfrom our sample data\nthrough statistical inferential methods, including estimation and testing\n\nDon’t worry if you have no idea of these terms.\nThese are what we will discuss throughout the course, and I’ll explain each term in detail later in class. OK."
  },
  {
    "objectID": "intro-data.html#data-matrix",
    "href": "intro-data.html#data-matrix",
    "title": "2  Data",
    "section": "2.2 Data Matrix",
    "text": "2.2 Data Matrix\n\nEach row corresponds to a unique case or observational unit.\nEach column represents a characteristic or variable.\nThis structure allows new cases to be added as rows or new variables as new columns.\n\n\n\n\n\n\n\n\n\n\n\nAnd we usually store a data set in a matrix form that has rows and columns.\nEach row corresponds to a unique case or observational unit, or the object.\nEach column represents a characteristic or variable.\nThis structure allows new cases to be added as rows or new variables as new columns.\nThe first step in conducting a study is to identify questions to be investigated.\nA clear research question is helpful in identifying\n\nwhat cases should be studied (row)\nwhat variables are important (column)\n\nTarget Population: The complete collection of data we’d like to make inference about.\nWhat is the average GPA of currently enrolled Marquette students?\n\n\n\n\n\n\n\n\n\n\n\nTarget Population: The complete collection of data we’d like to make inference about.\nSo the population is a set of all objects which we are interested in studying from.\nBecause All Marquette undergrads that are currently enrolled is the complete collection of data we’d like to make inference about.\nEach currently enrolled Marquette undergrad is an object.\nNote that students who are not currently enrolled or students that are already graduated are not our interest, and they shouldn’t be a part of target population.\nCan anybody tell me what variable associated with Marquette undergrads is our interest?\nSo average GPA is the variable or population property we like to make inference about."
  },
  {
    "objectID": "intro-data.html#sample-data",
    "href": "intro-data.html#sample-data",
    "title": "2  Data",
    "section": "2.3 Sample Data",
    "text": "2.3 Sample Data\n\nSometimes, it’s possible to collect data of all cases we are interested.\nMost of the time, it is too expensive to collect data for every case in a population.\nWhat about the average GPA of all students in Illinois? the U.S.? the world? 😱 😱 😱\n\n\n\n\n\n\n\nSample: A subset of cases selected from a population.\nCompute the average GPA of the sample data\nHope sample avg GPA \\(\\approx\\) population avg GPA. 🙏\nSo sampling is our solution to it.\nA Sample is A subset of cases selected from a population.\nAnd the idea is that OK, we are not able to compute the average GPA of a population, but we collect a sample from that population which has way less objects than the population.\nAnd then we compute the average GPA of the sample data.\nAnd we hope the sample average GPA can be close to the population average GPA because the population GPA is our main interest, not the sample GPA.\nTo have sample average GPA close to population GPA, we want the sample to look like the population so that the sample and the population share similar attribute including GPA."
  },
  {
    "objectID": "intro-data.html#statistics-is-a-science-of-data-so-what-is-data",
    "href": "intro-data.html#statistics-is-a-science-of-data-so-what-is-data",
    "title": "2  Data",
    "section": "2.1 Statistics is a Science of Data, so What is Data?",
    "text": "2.1 Statistics is a Science of Data, so What is Data?\n\nData: A set of objects on which we observe or measure one or more characteristics.\nObjects are individuals, observations, subjects or cases in statistical studies.\nA characteristic or attribute is called a variable because it varies from one to another.\n\n\n\n\n\n\n\n\n\n\n\nAll right. Statistics is a Science of Data, so What is Data?\nLet’s define Data.\nA data set is a set of objects on which we observe or measure one or more characteristics.\nObjects are individuals, observations, subjects or cases in statistical studies.\nA characteristic or attribute is called a variable because it varies from one to another.\nFor example, the data set right here is a set of Marquette basketball players.\nSo objects are individuals or players in the data.\nAnd each player has several characteristics or attributes shown in columns associated with him.\nFor example, his #, class, position, height, weight, hometown, and high school.\nThese characteristics are called variables because they vary form one to another. Clear?"
  },
  {
    "objectID": "intro-data.html#good-sample-vs.-bad-sample",
    "href": "intro-data.html#good-sample-vs.-bad-sample",
    "title": "2  Data",
    "section": "2.4 Good Sample vs. Bad Sample",
    "text": "2.4 Good Sample vs. Bad Sample\nIs this 4740/5740 class a sample data of the target population Marquette students?\nIs this 4740/5740 class a “good” sample of the target population?\n\nDoes this 4740 class look like the target population?\nThe sample is convenient to be collected, but it is NOT representative of the population.\nBiased sample: The average GPA of the class may be far from that of all MU undergrads.\n\n\n\n\n\n\n\nThe sample is convenient to be collected, but it is NOT representative of the population.\nYou are mostly STEM majors, and so with a high chance, your avg GPA is not the same as the GPA of humanities or business students,right.\nBiased sample: The average GPA of you guys may not be close to the average GPA of all Marquette undergrads.\nSample data must be collected in an appropriate way. If not GIGO.\n\n\n\n\n\n\nhttps://www.dailycal.org/2018/04/19/integrative-biology-computer-science-sociology-majors-lowest-gpa/"
  },
  {
    "objectID": "intro-data.html#how-and-why-a-representative-sample",
    "href": "intro-data.html#how-and-why-a-representative-sample",
    "title": "2  Data",
    "section": "2.5 How and Why a Representative Sample?",
    "text": "2.5 How and Why a Representative Sample?\n\nWe always seek to randomly select a sample from a population.\nLots of statistical methods are based on randomness assumption.\nWe always seek to randomly select a sample from a population because random sampling usually give us a Representative Sample, as long as the sample size, or the number of objects in the sample is not too small.\nIf data are not collected in a random framework, these statistical methods – the estimates and errors associated with the estimates – are not reliable."
  },
  {
    "objectID": "intro-data.html#data-collection",
    "href": "intro-data.html#data-collection",
    "title": "2  Data",
    "section": "2.6 Data Collection",
    "text": "2.6 Data Collection\n\nObservational Study: Observe and measure characteristics/variables, and do NOT attempt to modify or intervene with the subjects being studied.\n\n Sample from 1️⃣ the heart disease and 2️⃣ heart disease-free populations. Then record the fat content of the diets for the two groups. \n\nExperimental Study: Apply some treatment(s) and then proceed to observe its responses or effects on the individuals (experimental units).\n\nAssign volunteers to one of several diets with different levels of dietary fat (treatments). Then compare the treatments with respect to the incidence of hear disease after a period of time. \n\n\nObservational or Experimental? - Randomly select 40 males and 40 females to test the difference in blood pressure levels between male and female.  -  Test the effects of a new drug by randomly dividing patients into 3 groups (high dosage, low dosage, placebo). \n\nConfounder: A variable NOT included in a study but affects the variables in the study.\nObserve past data show that increases in ice cream sales are associated with increases in drownings, and we conclude that ice cream causes drownings. 😱 😕 ⁉️\n\nWhat is the confounder that is not in the data, but affects ice cream sales and the number of drownings?\nTemperature: as temperature increases, ice cream sales increase and the number of drownings goes up because more people swim.\nAs temperature increases (season), ice cream sales increase and the number of drownings goes up because more people swim."
  },
  {
    "objectID": "intro-data.html#causal-relationship",
    "href": "intro-data.html#causal-relationship",
    "title": "2  Data",
    "section": "2.7 Causal Relationship",
    "text": "2.7 Causal Relationship\n\nMaking causal conclusions based on experiments is often more reasonable than making the same causal conclusions based on observational data.\nObservational studies are generally only sufficient to show associations, not causality."
  },
  {
    "objectID": "intro-data.html#simple-random-sample",
    "href": "intro-data.html#simple-random-sample",
    "title": "2  Data",
    "section": "2.8 Simple Random Sample",
    "text": "2.8 Simple Random Sample\n\nRandom Sample: Each member of a population is equally likely to be selected.\nSimple Random Sample (SRS): Every possible sample of sample size \\(n\\) has the same chance to be chosen.\nExample: If sample 100 students from all, say 10,000 Marquette students, I would randomly assign each student a number (from 1 to 10,000), then randomly select 100 numbers.\n\n\n\n\n\n\n\n\n\n\n\nhttps://research-methodology.net/sampling-in-primary-data-collection/random-sampling/"
  },
  {
    "objectID": "intro-data.html#stratified-random-sample",
    "href": "intro-data.html#stratified-random-sample",
    "title": "2  Data",
    "section": "2.9 Stratified Random Sample",
    "text": "2.9 Stratified Random Sample\n\nStratified Sampling: Subdivide the population into different subgroups (strata) that share the same characteristics, then draw a simple random sample from each subgroup.\nHomogeneous within strata; Non-homogeneous between strata\n\n\n\n\n\n\n\nhomogeneous in terms of same characteristics of the subgroups. For example, same college.\nAnalyzing data from a stratified sample is a more complex task.\nExample: Divide Marquette students into groups by colleges, then SRS for each group."
  },
  {
    "objectID": "intro-data.html#cluster-sampling",
    "href": "intro-data.html#cluster-sampling",
    "title": "2  Data",
    "section": "2.10 Cluster Sampling",
    "text": "2.10 Cluster Sampling\n\nCluster Sampling: Divide the population into sections (clusters), then randomly select some of those clusters, and then choose all the members from those selected clusters.\nHomogeneous between clusters; Non-homogeneous within clusters\n\n\n\n\n\n\n\nExample: Conducting a study of STEM student drinking habit by randomly selecting 10 different STEM classes and interviewing all of the students in each of those classes.\n\n\n\n\n\n\n\nclusters look similar each other, but members in a cluster are not very alike. They have different characteristics.\nHomogeneous between clusters because all classes are STEM classes.\nNon-homogeneous within clusters because students in the same class may have different majors or from different colleges\nOK. We learn data collection and sampling methods.\nNow’s let’s learn some data types."
  },
  {
    "objectID": "intro-data.html#categorical-vs.-numerical-variables",
    "href": "intro-data.html#categorical-vs.-numerical-variables",
    "title": "2  Data",
    "section": "2.11 Categorical vs. Numerical Variables",
    "text": "2.11 Categorical vs. Numerical Variables\nA categorical (qualitative) variable provides non-numerical information which can be placed in one (and only one) category from two or more categories.\n\nGender (Male 👨, Female 👩, Other 🏳️‍🌈) \nClass (Freshman, Sophomore, Junior, Senior, Graduate) \nCountry (USA 🇺🇸, Canada 🇨🇦, UK 🇬🇧, Germany 🇩🇪, Japan 🇯🇵, Korea 🇰🇷) \nA numerical (quantitative) variable is recorded in a numerical value representing counts or measurements.\n\n GPA \n The number of relationships you’ve had \n Height"
  },
  {
    "objectID": "intro-data.html#numerical-variables-can-be-discrete-or-continuous",
    "href": "intro-data.html#numerical-variables-can-be-discrete-or-continuous",
    "title": "2  Data",
    "section": "2.12 Numerical Variables can be Discrete or Continuous",
    "text": "2.12 Numerical Variables can be Discrete or Continuous\n\nA discrete variable takes on values of a finite or countable number.\nA continuous variable takes on values anywhere over a particular range without gaps or jumps.\n\n GPA is continuous because it can be any value between 0 and 4. \n The number of relationships you’ve had is discrete because you can count the number and it is finite.\n Height is continuous because it can be any number within a range."
  },
  {
    "objectID": "intro-data.html#categorical-variables-are-usually-recorded-as-numbers",
    "href": "intro-data.html#categorical-variables-are-usually-recorded-as-numbers",
    "title": "2  Data",
    "section": "2.13 Categorical Variables are Usually Recorded as Numbers",
    "text": "2.13 Categorical Variables are Usually Recorded as Numbers\n\nGender (Male = 0, Female = 1, Others = 2) \nClass (Freshman = 1, Sophomore = 2, Junior = 3, Senior = 4, Graduate = 5) \nCountry (USA = 100, Canada = 101, UK = 200, Germany = 201, Japan = 300, Korea = 301) \nUnited Airlines boarding groups\nThe numbers represent categories only; differences between them are meaningless.\n\nCanada - USA = 101 - 100 = 1?\nGraduate - Sophomore = 5 - 2 = 3 = Junior?\n\nWe need to learn the level of measurements to know whether or which arithmetic operations are meaningful."
  },
  {
    "objectID": "intro-data.html#levels-of-measurements-nominal-and-ordinal-for-categorical-variables",
    "href": "intro-data.html#levels-of-measurements-nominal-and-ordinal-for-categorical-variables",
    "title": "2  Data",
    "section": "2.14 Levels of Measurements: Nominal and Ordinal for Categorical Variables",
    "text": "2.14 Levels of Measurements: Nominal and Ordinal for Categorical Variables\n\nNominal: The data can NOT be ordered in a meaningful or natural way.\n\nGender (Male = 0, Female = 1, Others = 2)  is nominal because Male, Female and Other cannot be ordered.\nCountry (USA = 100, Canada = 101, UK = 200, Germany = 201, Japan = 300, Korea = 301)  is nominal.\n\n\n\n\nOrdinal: The data can be arranged in some meaningful order, but differences between data values can NOT be determined or are meaningless.\n\nClass (Freshman = 1, Sophomore = 2, Junior = 3, Senior = 4, Graduate = 5)  is ordinal because Sophomore is one class higher than Freshman.\n\nInterval: The data have meaningful difference between any two values. But the data do NOT have a natural zero or starting point. The data can do \\(\\color{red} +\\) and \\(\\color{red} -\\), but can’t reasonably do \\(\\color{red} \\times\\) and \\(\\color{red} \\div\\).\n\nTemperature is interval because \\(80^{\\circ}\\)F is 40 degrees higher than \\(40^{\\circ}\\)F \\((80-40=40)\\), but \\(0^{\\circ}\\) does not mean NO heat and \\(80^{\\circ}\\)F is NOT twice as hot as \\(40^{\\circ}\\)F.\n\nRatio: The data have both meaningful differences and ratios, and there is a natural zero starting point that indicates none of the quantity. The data can do \\(\\color{red} +\\), \\(\\color{red} -\\), \\(\\color{red} \\times\\) and \\(\\color{red} \\div\\).\n\nDistance is ratio because \\(80\\) miles is twice as far as \\(40\\) miles \\((80/40 = 2)\\), and \\(0\\) mile means no distance."
  },
  {
    "objectID": "intro-data.html#converting-numerical-to-categorical",
    "href": "intro-data.html#converting-numerical-to-categorical",
    "title": "2  Data",
    "section": "2.15 Converting Numerical to Categorical",
    "text": "2.15 Converting Numerical to Categorical\n\n\n\nAttaching package: 'kableExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n\n\n\n\n \n  \n    Grade \n    Percentage \n  \n \n\n  \n    A \n    [94, 100] \n  \n  \n    A- \n    [90, 94) \n  \n  \n    B+ \n    [87, 90) \n  \n  \n    B \n    [83, 87) \n  \n  \n    B- \n    [80, 83) \n  \n  \n    C+ \n    [77, 80) \n  \n  \n    C \n    [73, 77) \n  \n  \n    C- \n    [70, 73) \n  \n  \n    D+ \n    [65, 70) \n  \n  \n    D \n    [60, 65) \n  \n  \n    F \n    [0, 60) \n  \n\n\n\n\n\nIdentify data type of each variable in the Marquette men’s basketball player data"
  }
]